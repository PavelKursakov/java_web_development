1: Как по терминологии Java называются базовый класс и наследуемый класс?  
**Ответ.** Класс, производный от другого класса, называется подклассом (также производным классом , расширенным классом или дочерним классом ). Класс, от которого происходит подкласс, называется суперклассом (также базовым классом или родительским классом ).  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html  

2: Какой класс является родительским для всех классов?  
**Ответ.** В отсутствие какого-либо другого явного суперкласса каждый класс неявно является подклассом Object.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html  

3: Какой класс является родительским для всех перечислений?  
**Ответ.** Перечисление в Java относится к типу класса, но перечисление НЕ может наследоваться от другого класса и НЕ может быть супер классом.
Все перечисления автоматически наследуют от класса java.lang.Enum. В этом классе определяется ряд методов, доступных для использования во всех перечислениях: ordinal(), compareTo(), equals(), values() и valueOf().
Перечисления также неявно наследуют интерфейсы Serializable и Comparable.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/perechisleniya#header3  

4: Какой интерфейс является родительским для всех интерфейсов?  
**Ответ.** В языке программирования Java интерфейс - это ссылочный тип, подобный классу, который может содержать только константы, сигнатуры методов, методы по умолчанию, статические методы и вложенные типы. Тела методов существуют только для методов по умолчанию и статических методов. Интерфейсы не могут быть созданы - они могут быть реализованы только классами или расширены другими интерфейсами. Родительского интерфейса для всех всех интерфейсов нет.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html

5: Сформулируйте критерий отношения наследования между двумя сущности физического мира.
Другими словами, какому условию должны удовлетворять две сущности физического мира, чтобы соответствующие им классы были связаны отношением наследования?  
**Ответ.** Наследование реализует отношение «является» (“is-a”) между суперклассом и подклассом. Пусть, например, классы Employee и Manager представляют собой абстракцию понятий «Сотрудник» и «Менеджер». Каждый менеджер также является сотрудником компании, в которой он работает, следовательно, класс Manager находится в отношении “is-a” с классом Employee. Таким образом, с точки зрения наследования, при выстраивании иерархии классов класс Employee будет являться суперклассом, а класс Manager – дочерним классом. При этом класс, который является наследником какого-либо класса, может быть суперклассом для одного или нескольких других классов.Класс Employee в примере выше является суперклассом не потому, что он главнее класса Manager или содержит больше функциональности. На самом деле верно обратное: функциональность подклассов не ýже, а зачастую существенно шире, чем функциональность их классов-родителей.
Для того чтобы унаследовать какой-либо класс в Java, используется ключевое слово extends.  

6: Есть ли отношение наследования между сущностями:
а) квадрат и прямоугольник;
б) сосна и доска;
в) книга и страница?
Поясните ответ.  
**Ответ.**  
а) Да. Изначально есть прямоугольник, а уже его можно представить прямоугольником с одинаковыми сторонами (квадратом). Значит прямоугольник это суперкласс, а квадрат это подкласс.  
б) Нет. Доска это объект созданый из сосны, он не несет того же функционала, что и сосна. Правильное насследование выглядело бы как : Дерево (суперкласс) и Сосна (подкласс).  
в) К отношение книги и страницы логиченее описать как Композицию, книга состоит из страниц, и без страниц ее существование не имеет смысла. Соответсвенно наследование в данном случае так же не логично.  


7: В jdk класс RuntimeException является подклассом Exception.
Есть ли нарушение критерия наследования?
Поясните ответ.  
**Ответ.**
RuntimeException (unchecked), наследуется от класса Exception, который является (checked) по нескольким причинам:  

а) Проверяемость тех или иных классов явно прописана в спецификации и не связана с какими-либо свойствами классов-исключений. Наследование имеет чисто организационный/иллюстративный характер и не связано с наследованием свойств/методов.  
б) Проверяемое исключение — это исключение, а не ошибка, и должно обрабатываться как исключение.  
в) Разработчики Java приняли решение, что базовый класс исключений должен быть проверяемым.  

8: В чем смысл конструкции `super`?
Перечислите случаи, когда используется конструкция  `super`.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими
возможностями. Если можно, то каким образом?  
**Ответ.** Если ваш метод переопределяет один из методов своего суперкласса, вы можете вызвать переопределенный метод с помощью ключевого слова `super`. Вы также можете использовать `super` для ссылки на скрытое поле (хотя скрытие полей не рекомендуется).
Внутри класса для вызова своего конструктора без аргументов используется `this()`, тогда как `super()` используется для вызова конструктора без аргументов, или как его ещё называют, конструктора по умолчанию родительского класса. Между прочим, таким способом вызывать можно не только конструктор без аргументов, а и вообще любой другой конструктор, передав ему соответствующие параметры.
Ещё `this` и `super` в Java используются для обращения к переменным экземпляра класса и его родителя. Вообще-то, к ним можно обращаться и без префиксов `super` и `this`, но только если в текущем блоке такие переменные не перекрываются другими переменными, т.е. если в нем нет локальных переменных с такими же именами, в противном же случае использовать имена с префиксами придется обязательно.
Классическим примером такого подхода является использование `this` внутри конструктора, который принимает параметр с таким же именем, как и у переменной экземпляра.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html  
https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java  

9: Можно ли одновременно использовать `this()` и `super()` в конструкторе?
Поясните ответ.  
**Ответ.** Внутри конструктора `this` и `super` должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и `this()`, и `super()`.  
**Источник.** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java  

10: Дан код.
```java
class SomeClass() {
...
public SomeClass() {
doSmth();
}
protected void doSmth() {
...
}
}
```
Это потенциальный антипаттерн. Почему?  
**Ответ.** Модификатор доступа у метода должен быть private.
вызов метода экземпляра в конструкторе опасен, потому что объект еще не полностью инициализирован (это относится в основном к методам, которые могут быть переопределены). Также известно, что сложная обработка в конструкторе оказывает негативное влияние на тестируемость.  

11: Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все методы, объявленные в интерфейсе?  
**Ответ.** ЕКласс, реализующий интерфейс, должен реализовать все методы, объявленные в интерфейсе.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/summary-interface.html

12: Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?  
Если класс реализует интерфейс, то этот интерфейс может служить как некий тип, который можно использовать для ссылки на экземпляры этого класса. То, что класс реализует некий интерфейс, должно говорить нечто о том, что именно клиент может делать с экземплярами этого класса. Создавать интерфейс для каких-либо иных целей неправомерно.
Среди интерфейсов, которые не отвечают этому критерию, числится так называемый интерфейс констант (constant interface). Он не имеет методов и содержит исключительно поля static final, передающие константы. Классы, в которых эти константы используются, реализуют данный интерфейс для того, чтобы исключить необходимость в добавлении к названию констант названия класса.  
**Источник.** https://studfile.net/preview/5021192/page:10/  

13: Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?  
**Ответ.** Когда переопределенный метод вызывается через ссылку супер- класса, Java определяет, какую версию метода вызвать, основываясь на типе объекта, на который имеется ссылка. Таким образом, тип объекта определяет версию метода на этапе выполнения. Исходя из этого можно сделать вывод, что переопределние метода в одном и том же классе не допустимо, т.к. компилятор выбирает для реализации только один метод со идентичным названием и типом переданных данных. Для изменения функционала метода используется перегрузка метода. Вы можете перегрузить методы, это новые методы, уникальные для класса.  
**Источник.**  И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 129.  
https://docs.oracle.com/javase/tutorial/java/IandI/override.html

14: Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?  
**Ответ.** Да, если объявление метода подкласса полностью, включая параметры, совпа- дает с объявлением метода суперкласса (порождающего класса), то метод под- класса переопределяет (overriding) метод суперкласса. Переопределение мето- дов является основой концепции динамического связывания, реализующей полиморфизм. Когда переопределенный метод вызывается через ссылку супер- класса, Java определяет, какую версию метода вызвать, основываясь на типе объекта, на который имеется ссылка. Таким образом, тип объекта определяет версию метода на этапе выполнения. Для изменения функционала метода используется перегрузка метода. В подклассе вы можете перегрузить методы, унаследованные от суперкласса. Такие перегруженные методы не скрывают и не переопределяют методы экземпляра суперкласса - это новые методы, уникальные для подкласса.  
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 129.  
https://docs.oracle.com/javase/tutorial/java/IandI/override.html  

15: Можно ли переопределить статический метод? Поясните ответ.  
**Ответ.** Для статических методов принципы «позднего связывания» не работают. Динамический полиморфизм к статическим методам класса неприменим, так как обращение к статическому атрибуту или методу осуществляется по типу ссылки, а не по типу объекта, через который производится обращение. Версия вызываемого статического метода всегда определяется на этапе компиляции. При использовании ссылки для доступа к статическому члену компилятор при выборе метода учитывает тип ссылки, а не тип объекта, ей присвоенного.  
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) 134  

16: Как запретить переопределение метода в подклассе? Назовите 2 способа.  
**Ответ.** 
а) Чтобы запретить переопределение метода, в начале его объявления следует указать ключевое слово final.
Методы, объявленные как final, переопределяться не могут.  
б) Дать коду модификатор доступа private.  
**Источник.** https://pro-java.ru/java-dlya-opytnyx/predotvrashhenie-pereopredeleniya-s-pomoshhyu-klyuchevogo-slova-final-v-java/  

17: С помощью какого механизма реализуется полиморфизм в Java?  
**Ответ.** Механизм «позднего связывания» или «динамического полиморфизма» в процессе выполнения программы определяет принадлежность объекта кон- кретному классу и производит вызов метода, относящегося к классу, объект которого был использован. Механизм «позднего связывания» позволяет опре- делять версию полиморфного (виртуального) метода во время выполнения программы, то есть невозможно на этапе компиляции определить, какая версия переопределенного метода будет вызвана на этапе выполнения программы.  
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 65-66.  

18: Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть ссылка на объект суперкласса? Если да, то как ее получить?  
**Ответ.** Да, Вы также можете использовать super для ссылки на скрытое поле (хотя скрытие полей не рекомендуется). Ссылка на объект суперкласса получается с помощью super.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html  

19: SmallEntity и BigEntity - это подклассы Entity.
Можно ли отрефакторить данный код? Если да, то выполните.
```java
class EntityFactory {
public static Entity getEntity(int num) {
switch(num) {
case 2: return new Entity();
case 3: return new SmallEntity();
case 4: return new BigEntity();
default: throw new IllegalArgumentException();
}
}
}
```
**Ответ.**  
```java
class EntityFactory {
  private enum EntityKind {
ENTITY {
Entity getEntity (){
        return new Entity();
}
},
SMALL_ENTITY {
Entity getEntity (){
        return new SmallEntity();
}
},
BIG_ENTITY {
Entity getEntity (){
        return new BigEntity();
}
};
     abstract Entity getEntity();
}
}
```

20: Можно ли отрефакторить данный код? Если да, то выполните.
```java
class Entity {
...
private String action;
public void doSmth() {
switch(action) {
case "sing-solo": singSolo(); break;
case "sing-duet": singDuet(); break;
case "dance": dance();
}
}
private void singSolo() {
...
}
private void singDuet() {
...
}
private void dance() {
...
}
}
```
**Ответ.**  
```java
class Entity{
    enum Cases{
        SING_SOLO{
            void doSmth();
        },
        SING_DUET{
            void doSmth();
        },
        DANCE{
            void doSmth();
        };
        abstract void doSmth();
    }
}
```

21: Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а?
Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:
1. b = i; ?
2. i = b; ?  
**Ответ.**
а) Да, создать объект класса можно по ссылке на расширяемый им класс. Объекты таких классов нельзя создать с помощью оператора new, но можно создать объекты подклассов, которые реализуют все эти методы. При этом допустимо объявлять ссылку на абстрактный класс, но инициализировать ее можно только объектом производного от него класса.
б) Да, мы можем создать объект класса B по ссылке a. Так же мы можем создать объект B по ссылке i.
Присваивание b = i невозможно.
Присваивание i = b возможно.
Пример:  
```java
public abstract class A { // create abstract class A
}
public class B extends A implements I { //create extending class B
}
public interface I { // create interface I
}
class Runner {
    public static void main(String[] args) {
        A a;
        I i;
        B b = new B();
        a = new B();
        i = new B();
        b = i; // Assignment error
        i = b;
    }
}
```
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр 134, стр 184  
https://coderoad.ru/4989818/instanceof-Vs-getClass#4989843  

22: В чем заключается отличие сравнения принадлежности к классу через операцию instanceof и метод getClass()?  
**Ответ.** Оператор instanceof служит для проверки к какому классу принадлежит объект. a instanceof B возвращает истину, если в переменной a содержится ссылка на экземпляр класса B, подкласс B (напрямую или косвенно, иначе говоря, состоит в иерархии наследования классов) или реализует интерфейс B (так же напрямую или косвенно). В то время как метод getClass() возвращает класс объекта, содержащий сведения об объекте: public final Class<?> getClass(). Как Вы можете заметить метод является конечным и переопределению не подлежит. С методом getClass() все обстоит несколько проще и очевидней нежели с оператором instanceof.
Метод прост и эффективен, ровно до тех пор, пока не применен механизм наследования. При наследовании этот метод становится менее полезным.  
**Источник.** https://javanerd.ru/%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-java/%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-java/  

23: Можно ли создать:
1. ссылку на объект абстрактного класса?
2. объект абстрактного класса?
3. ссылку на интерфейс?
4. объект типа интерфейс?  
**Ответ.** 
   а) У абстрактного класса в Java не может быть никаких объектов. Но абстрактные классы можно применять для создания ссылок на объекты. Например:  
```java
public abstract class Figure2 {

    ...
    public abstract double calculateArea();

    public static void main(String[] args) {
         // У абстрактного класса не может быть никаких объектов.
         // Figure2 figure1 = new Figure2();
         // Но абстрактные классы можно применять для создания ссылок на объекты.
	 Figure2 figure2 = new Rectangle();
    }
}
```
б) Абстрактный класс похож на обычный класс. В абстрактном классе также можно определить поля и методы, но в то же время нельзя создать объект или экземпляр абстрактного класса.  
в) Поскольку, интерфейс содержит только объявление без реализации, то создать экземпляр интерфейса запрещено. Однако, ссылку на интерфейс объявить можно. Но при выделении памяти оператором new должен указываться конструктор класса, который реализует данный интерфейс.  
г) Интерфейсы — это не классы. С помощью ключевого слова new нельзя создать экземпляр интерфейса:  
`х = new List(...); // Нельзя!`  

**Источник.** https://www.examclouds.com/ru/java/java-core-russian/abstract-metodi-klassi  
https://metanit.com/java/tutorial/3.6.php  
https://www.bestprog.net/ru/2019/03/28/interfaces-features-of-use-in-combination-with-classes-the-benefits-of-using-interfaces-keywords-interface-implements-examples-ru/  
http://developer.alexanderklimov.ru/android/java/interface.php  



24: Может ли класс:
1. реализовывать два интерфейса?
2. расширять два класса?
3. расширять два интерфейса?
4. расширять один класс и реализовывать один интерфейс?
5. расширять сам себя?  
**Ответ.**  
а) Ваш класс может реализовать более одного интерфейса, поэтому после implementsключевого слова следует список интерфейсов, реализованных классом, через запятую.  
б) Нет, в отличие от C++, вы не можете расширить несколько классов, но вы можете реализовать несколько интерфейсов.
в) Класс в Java может расширить только один родительский класс. Множественное наследование невозможно. Однако интерфейсы не классы, и интерфейс может расширить более чем один родительский интерфейс.  
г) Класс может расширить только один класс, но реализовать множество интерфейсов.  
д) Класс в Java может расширить только один родительский класс. Множественное наследование невозможно.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/usinginterface.html  
   https://coderoad.ru/16233345/%D0%95%D1%81%D1%82%D1%8C-%D0%BB%D0%B8-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1-%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B8%D1%82%D1%8C-%D0%B4%D0%B2%D0%B0-%D0%B8%D0%BB%D0%B8-%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2-%D0%B2-java  
   http://proglang.su/java/interfaces  
   
   
25: Для каких целей используется расширение интерфейса?  
**Ответ.** Интерфейс может расширять другой интерфейс так же, как класс другой класс. Ключевое слово extends используется для расширения интерфейса, и дочерний интерфейс наследует методы родительского интерфейса.
Приведённый интерфейс Sports расширен интерфейсами Hockey и Football.  
```java
// Filename: Sports.java
public interface Sports {
   public void setHomeTeam(String name);
   public void setVisitingTeam(String name);
}

// Filename: Football.java
public interface Football extends Sports {
   public void homeTeamScored(int points);
   public void visitingTeamScored(int points);
   public void endOfQuarter(int quarter);
}

// Filename: Hockey.java
public interface Hockey extends Sports {
   public void homeGoalScored();
   public void visitingGoalScored();
   public void endOfPeriod(int period);
   public void overtimePeriod(int ot);
}
```
Интерфейс Hockey имеет четыре метода, но он наследует два из Sports; таким образом, класс, который реализует Hockey, должен реализовать все шесть методов. Подобно этому, класс, который реализует Football, должен определить три метода из Football и два метода из Sports.  
**Источник.** http://proglang.su/java/interfaces#rasshirenie-interfeysov  

26: Могут ли в интерфейсе быть поля?  
**Ответ.**  Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final). Все методы и переменные неявно объявляются как public.  
**Источник.** http://developer.alexanderklimov.ru/android/java/interface.php  

27: Можно ли в интерфейсе
1. объявить метод с пакетным уровнем доступа?
2. объявить конструктор?
3. определить конструктор?  
**Ответ.** 
   а) Все методы интерфейса не имеют модификаторов доступа, но фактически по умолчанию доступ public, так как цель интерфейса - определение функционала для реализации его классом. Поэтому весь функционал должен быть открыт для реализации.  
   б,в) Интерфейс не содержит конструкторов. Интерфейс может объявить готовые методы. Появление объявления поля в тексте неявно общедоступно, статично и окончательно. Разрешены избыточно любые или все эти модификаторы для таких полей.  
   **Источник.** https://metanit.com/java/tutorial/3.7.php  
   http://proglang.su/java/interfaces  

28: Можно ли интерфейс объявить финальным? Поясните ответ.  
**Ответ.** Интерфейсы на 100% абстрактны. Разрешать лицом быть final совершенно бессмысленно.  

29: Можно ли в интерфейсе объявить статический метод? Поясните ответ.  
**Ответ.** Вообще с 8й версии можно static, но нужно чтобы было тело метода. Например:  
```java
public interface Shape {
    static void draw() {
        System.out.println("Wow! It is impossible!");
    };
}
```
**Источник.** https://javastudy.ru/interview/java-oop2/  

30: Можно ли вызвать статический метод через объектную ссылку? Поясните ответ.  
**Ответ.** Вызов статического метода всегда следует использовать с указанием имени класса, а не объекта. Статический метод может быть получен также с использованием имени объекта, но такой вызов оценки качества кода, обеспечивает точность достижения и не будет смешивать корректным образом, хотя и не приводит к ошибочной компиляции.  
**Источник.** И.Н. Блинов В.С. Романчик Java от EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 83.  

31: Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то зачем?  
**Ответ.** Производный класс обязан переопределить и реализовать все абстрактные методы, которые имеются в базовом абстрактном классе. Также следует принять во внимание, что данный класс должен быть определен как абстрактный метод. Экземпляры абстрактного класса создавать невозможно.  
**Источник.** https://metanit.com/java/tutorial/3.6.php  

32: Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то зачем объявлять такой класс абстрактным?  
**Ответ.** описание класса может и не обнаружение абстрактных методов. Назначение такого класса — быть вершиной иерархии его различных реализаций.  
И.Н. Блинов В.С. Романчик Java от EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 134.  

33: Что означает ключевое слово final в следующих конструкциях?
1.
```java
public final class SomeClass() { }
```
2.
```java
public class SomeClass() {
public final void doSmth();
}
```
**Ответ.** 
а) Если в системе возникнет подозрение, состояние, которое нельзя изменить, то процедура реализации такой задачи представляется в виде публичного финального класса. Таким образом применяется запрет на расширение данного класса.  
б) Что бы запретить переопределять метод в порожденном классе, если в суперклас-се он объявил со-преступником final.  
**Источник.**  И.Н. Блинов В.С. Романчик Java от EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 101, стр. 125  

34: Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.  
**Ответ.** Финальный абстрактный метод не имеет смысла для сущетсвования. предполагаемый метод для последующего его переопределения уков или классов, реализующих интерфейс. finalзапрещает переопределять метод, соотвественно такое общедоступно.  
**Источник.** И.Н. Блинов В.С. Романчик Java от EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 125. 134.  

35: К каким методам неприменимы принципы позднего связывания? Почему?  
**Ответ.** Статическое связывание используется в языке Java для разрешения перегруженных методов, в то время как динамическое связывание используется в языке Java для разрешения переопределенных методов. Приватные, статические и терминальные методы разрешаются при помощи статического связывания, поскольку их нельзя переопределять, а все виртуальные методы разрешаются при помощи динамического связывания.  
**Источник.** https://javarush.ru/groups/posts/439-razlichija-mezhdu-rannim-i-pozdnim-svjazihvaniem-v-java  

36: В чем заключается отличие между ранним и поздним связыванием?  
**Ответ.**  
а) Статическое связывание происходит во время компиляции, а динамическое – во время выполнения.  
б) Поскольку статическое связывание происходит на ранней стадии жизненного цикла программы, его называют ранним связыванием. Аналогично, динамическое связывание называют также поздним связыванием, поскольку оно происходит позже, во время работы программы.  
в) Статическое связывание используется в языке Java для разрешения перегруженных методов, в то время как динамическое связывание используется в языке Java для разрешения переопределенных методов.  
г) Аналогично, приватные, статические и терминальные методы разрешаются при помощи статического связывания, поскольку их нельзя переопределять, а все виртуальные методы разрешаются при помощи динамического связывания.  
д) В случае статического связывания используются не конкретные объекты, а информация о типе, то есть для обнаружения нужного метода используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода в Java используется конкретный объект.  
**Источник.** https://javarush.ru/groups/posts/439-razlichija-mezhdu-rannim-i-pozdnim-svjazihvaniem-v-java  
