**Theory classes**

1: Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?  
**Ответ.**  Модификаторы уровня доступа определяют, могут ли другие классы использовать определенное поле или вызывать определенный метод. Есть два уровня контроля доступа: На верхнем уровне `public-` или `package-private` (без явного модификатора).  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html  

2: Что является членами класса?  
**Ответ.** Класс в Java - это шаблон для создания объекта, а объект - это экземпляр класса. Класс определяет структуру и поведение, которые будут совместно использоваться набором объектов. Класс содержит переменные и методы, которые называются элементами класса, членами класса.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/oop-klassi-metodi  

3: Что еще можно определить в классе кроме членов?
**Ответ.** Конструктор класса, статический блок инициализации класса, блок инициализации экземпляра.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.6

4: Какие уровни доступа есть у членов класса?  
**Ответ.**  
   `public` (общедоступный);  
   `protected` (защищенный);  
   `default` (также называемый пакетным доступом);  
   `private` (закрытый).  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик стр. 68-69  

5: Какие модификаторы необходимы для определения константы:
а) класса,
б) экземпляра класса?  
**Ответ.**  
а) `static final`  
б) Модификатор `final`  

6: Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
class SomeClass {
private int a;
private final int b;
private static int c;
private static final int D;
...
}
7: Как можно назвать данные поля в зависимости от комбинации модификаторов `static` и `final`?  
**Ответ.**  
   private int a; (приватное поле)  
   private final int b; (приватное финальное поле)  
   private static int c; (приватное статическое поле)  
   private static final int D; (приватное статическое финальное поле)  

8: Может ли класс не иметь ни одного конструктора? Почему?  
**Ответ.** Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (default constructor), который будет пустым и не делает ничего, кроме вызова конструктора суперкласса.  
**Источник.**  https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

9: Перечислите отличия конструктора от метода.  
**Ответ.** Конструктор - это специальный метод, который вызывается при создании нового объекта. В отличие от метода, конструктор никогда ничего не возвращает. Конструктор определяет действия, выполняемые при создании объекта класса, и является важной частью класса. Как правило, программисты стараются явно указать конструктор.  
**Источник.** http://developer.alexanderklimov.ru/android/java/constructor.php  

10: Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?  
**Ответ.**  Для этого используется ключевое слово this, после которого в круглых скобках указываем параметры для соотвествующего конструктора.  
Вы можете вызвать один конструктор из другого в том же классе, или в надклассе, со следующими ограничениями:  
Вызываемый конструктор должен быть в первой строке кода в вызывающем конструкторе.  
Вложенный конструктор не может иметь никакой явной или неявной ссылки на "this". Таким образом, вы не можете попасть во внутренний класс.  
**Источник.** https://javarush.ru/groups/posts/793-vihzov-konstruktora-iz-konstruktora  

11: Как и в каком месте можно вызвать конструктор суперкласса?  
**Ответ.** Конструктор суперкласса (базового класса) может быть вызван из подкласса (производного класса). Этот вызов осуществляется с помощью ключевого слова super. Вызов конструктора суперкласса должен быть осуществлен в теле конструктора подкласса первым.  
**Источник.** https://www.bestprog.net/ru/2019/06/07/java-inheritance-a-reference-to-a-subclass-object-calling-the-superclass-constructor-the-keyword-super-ru/  

12: Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?  
**Ответ.** Если конструктор не создается, автоматически создается пустой конструктор по умолчанию .

Если какой-либо конструктор явно не вызывает super или этот конструктор в качестве своего первого оператора, автоматически добавляется вызов `super()` .

Всегда.  

13: Можно ли одновременно использовать конструкции `this()` и `super()` в одном и том же конструкторе?
Обоснуйте ответ.  
**Ответ.** Внутри конструктора `this` и `super` должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и `this()`, и `super()`.  
**Источник.** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java  

14: Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?  
**Ответ.**  Создание чего-то private не означает, что никто не сможет получить к нему доступ. Это просто означает, что никто за пределами класса не может получить к нему доступ. Поэтому конструктор private тоже полезен.
Одним из использования конструктора private является использование одноэлементных классов. Класс singleton - это тот, который ограничивает количество создания объектов одним. Используя конструктор private, мы можем гарантировать, что за один раз может быть создано не более одного объекта.  

15: Какие модификаторы может иметь конструктор?  
**Ответ.** Конструкторы могут быть public, private, protected или default (вообще нет модификатора доступа).  

16: Конструктор принадлежит классу или экземпляру класса?  
**Ответ.** Конструктор принадлежит классу. Но в то же время, конструктор вызывается в контексте экземпляра.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.3

17: Можно ли наследовать конструктор?  
Если да, то приведите примеры.  
**Ответ.** подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса. в Java конструкторы не являются членами, поэтому они не наследуются подклассом, но конструктор суперкласса может быть вызван из подкласса.  
**Источник.** http://proglang.su/java/inheritance  

18: Какой тип возвращаемого конструктором значения?  
**Ответ.** Конструктор не должен иметь тип возврата. По определению, если метод имеет тип возвращаемого значения, он не является конструктором.  

19: Дан класс.
class Null {
//фрагмент 1
Null Null() {
return null;
}
//фрагмент 2
Null() {
return null;
}
}
В каком фрагменте ошибка компиляции?
Удалите этот фрагмент полностью.
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.  
**Ответ.**  Второй фрагмент является конструктором. Он ничего не должен возвращать, поэтому он неверен. Первый фрагмент верен, но согласно соглашению, называть методы так же, как и класс неверно, так именуются конструкторы. Этот фрагмент вернет `null`.  
```java
public static void main(String[] args) {
  Null object = new Null();
  object = object.Null();
  System.out.println(object); // null
}
```

20: Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?  
**Ответ.** Конструктор не имеет возвращаемого значения. Если при определении конструктора указан тип возвращаемого значения (фрагмент 1) , то он считается методом Пример:  
```java
class Null {  
       //фрагмент 1  
       Null Null() {  
           return null;  
       }  
   } 
    
   public class Runner {
       public static void main(String[] args) {
           Null exampleNull  = new Null();
           System.out.print(exampleNull.Null());
       }

   }
   ```
Результат работы программы: `null`.  

21: Дан класс.
class Name {
String name;
Name() {
this(makeRandomName());
}
Name(String name) {
super();
this.name = name;
}
String makeRandomName() {
int k = (int) (Math.random() * 3);
String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
return name;
}
public String toString() {
return name;
}
public static void main(String[] args) {
System.out.println(new Name());
}
}
Объясните причину ошибки компиляции.
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.  
**Ответ.**  Чтобы сработал данный код, метод makeRandomName() должен быть статичным, т.к. на этапе работы кода из конструктора объект еще не создан, и обратиться к данному методу нельзя. 1 способ - установить для метода модификатор static. 2 способ устранения — провести прямую инициализацию name в непараметризованном конструкторе:  
```java
name = makeRandomName();
```
  
22: Дан класс.
class Int {
int i;
void inc(Int param) {
//param = new Int();
param.i++;
}
public static void main(String[] args) {
Int obj = new Int();
obj.inc(obj);
System.out.println(obj.i);
}
}
Изменится ли результат, если убрать комментарий?
Объясните, почему?  
**Ответ.** Если убрать комментарий, то в этой строке кода создастся новый локальный объект Int(), значение которого будет увеличено на +1, при этом передающийся в метод аргумент останется неизменным, т.к. param примет ссылку на новый объект, и будет работать уже с ним, а с переданным аргументом не будет производиться никаких операций.  

23: В чем смысл конструкции this?
Перечислите случаи, когда используется конструкция this.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?  
**Ответ.** Каждый экземпляр класса (объект) имеет неявную ссылку this на себя, которая передается также неявно и нестатическим методам класса. После этого каждый метод «знает», какой объект его вызвал. Вместо обращения к атрибуту accountId в методах можно писать this.accountId, хотя и не обязательно, так как записи accountId, this.accountId и Account.this. accountId равносильны. Но если в методе объявлена локальная переменная или параметр метода с таким же именем, как и поле класса, то для обращения к полю класса использование this обязательно. Без использования указателя обращение всегда будет производиться к локальной переменной, так как просто не существует другого способа ее идентификации. Наиболее частая причина использования ключевого слова this заключается в том, что поле затенено параметром метода или конструктора. Изнутри конструктора вы также можете использовать ключевое слово this для вызова другого конструктора в том же классе. Это называется явным вызовом конструктора . Например, класс Point был написан так:  
```java
public class Point {
       public int x = 0;
       public int y = 0;

       //constructor
       public Point(int a, int b) {
           x = a;
           y = b;
       }
   }
   ```  
но это можно было бы написать так:  
```java
public class Point {
       public int x = 0;
       public int y = 0;
   
       //constructor
       public Point(int x, int y) {
           this.x = x;
           this.y = y;
       }
   }
   ```
**Источник.** И. Блинов Java from Epam стр. 71
https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html  

24: Можно ли присвоить null ссылочной переменной this?  
**Ответ.**  Нет, нельзя. В Java левая часть оператора присваивания должен быть переменной. this — это специальное ключевое слово, которое всегда дает текущий экземпляр класса. Это не любая переменная. Точно также, null нельзя присвоить переменной, используя ключевое слово super или любое другое подобное.  
**Источник.**  https://javarush.ru/groups/posts/780-java-core-voprosih-k-sobesedovaniju-ch-3  

25: Перечислите случаи, когда используется статический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** Блок статической инициализации - это обычный блок кода, заключенный в фигурные скобки { }, и которому предшествует static ключевое слово. Вот пример:  
```java
static {  
       // любой код, необходимый для инициализации, идет сюда  
   } 
   ```  
Класс может иметь любое количество статических блоков инициализации, и они могут появляться в любом месте тела класса. Система времени выполнения гарантирует, что статические блоки инициализации вызываются в том порядке, в котором они появляются в исходном коде. Есть альтернатива статическим блокам - вы можете написать приватный статический метод.Методы класса не могут напрямую обращаться к переменным экземпляра или методам экземпляра - они должны использовать ссылку на объект. Кроме того, методы класса не могут использовать ключевое слово this, поскольку нет экземпляра, на который можно было бы ссылаться `this`.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html   

26: Перечислите случаи, когда используется логический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** При описании класса могут быть использованы логические блоки. Логическим блоком называется код, заключенный в фигурные скобки и не принадлежащий ни одному методу текущего класса, например:  
```java
{ /* code */ }  
   static { /* code */ }  
   ```
Логические блоки чаще всего используются в качестве инициализаторов полей, но могут содержать вызовы методов и обращения к полям текущего класса. При создании объекта класса они вызываются последовательно, в порядке размещения, вместе с инициализацией полей как простая последовательность операторов, и только после выполнения последнего блока будет вызван конструктор класса. Операции с полями класса внутри логического блока до явного объявления этого поля возможны только при использовании ссылки this, представляющей собой ссылку на текущий объект На практике статические логические блоки могут применяться для проверки и инициализации базовых параметров, необходимых для функционирования приложения или класса. Нестатичексие логические блоки могут применяться для проверки и инициализации параметров конкретного объекта и для сокращения количества кода, если одинаковый код присутствует в каждом конструкторе.  
**Источник.** И. Блинов Java from Epam стр. 85

27: Что входит в сигнатуру метода?  
**Ответ.** В более общем смысле, объявления методов состоят из шести компонентов в следующем порядке: Модификаторы доступа. Тип возврата - тип данных значения, возвращаемого методом, или void если метод не возвращает значение. Имя метода - правила для имен полей применяются также к именам методов, но соглашение немного отличается. Список параметров в скобках-разделенный запятыми список входных параметров, которым предшествуют их типы данных, заключенные в скобки,(). Если параметров нет, необходимо использовать пустые скобки. Список исключений Тело метода, заключенное в фигурные скобки - это код метода, включая объявление локальных переменных.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html  

28: Что значит ключевое слово native?  
**Ответ.**  Если к методу применяется ключевое слово native, то это означает, что метод будет реализован с использованием собственного кода, написанного на другом языке (например, C или C ++) через JNI (собственный интерфейс JAVA).  
**Источник.** https://ru.education-wiki.com/8247106-native-keyword-in-java  

29: Дан код.
public class BusinessTrip {
…
public String bynToStr(int value) {
return (value / 100) + "." + (value / 10 % 10) + (value % 10);
}
}
Есть ли в нем семантическая ошибка?
Если да, то обоснуйте.  
**Ответ.** Если метод предполагает использование только внутри данного класса, то он должен быть private static, т.к. по его логике он принимает значение вне зависимоти от данных экземпляра класса. Если метод может быть использован вне данного класса, то его стоит определить в отдельном утилитном классе и так же сделать статическим.  

30: Дан код.
public class Utility {
private Utility() {
}
public String bynToStr(int value) {
return (value / 100) + "." + (value / 10 % 10) + (value % 10);
}
}
Есть ли в нем семантическая ошибка?
Если да, то предложите альтернативные варианты.  
**Ответ.** сделав метод статичным мы избавимся от проблемы, однако, стоит отметить другое: для вызова bynToStr() экземпляр класса не нужен, а нестатический метод в утилитном классе — это антипаттерн.  

31: К каким данным можно обратиться в статическом методе?  
**Ответ.** Модификатор static в Java напрямую связан с классом. Если поле статично, значит оно принадлежит классу, если метод статичный — аналогично: он принадлежит классу. Исходя из этого, можно обращаться к статическому методу или полю, используя имя класса. Например, если поле count статично в классе Counter, значит, вы можете обратиться к переменной запросом вида: Counter.count.  
**Источник.** https://javarush.ru/groups/posts/modifikator-static-java

32: Почему нельзя объявить статическое поле внутри метода?  
**Ответ.** Внутри метода объявляются только локальные переменные метода, доступные только внутри метода.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html

33: Перечислите, какой код в классе можно выполнить до создания объекта.  
**Ответ.**  
а) Статический блок инициализации.  
б) Логический блок инициализации.  
в) Статические члены класса.  
**Источник.**  И. Блинов Java from Epam стр. 81
https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4

34: В чем различие между объектом и экземпляром класса?  
**Ответ.** Java объект - чуть более широкое понятие чем экземпляр класса, включает в себя такие понятия, как “экземпляр класса” и “массив”.  
```java
public class Cat  // объявление класса Cat  
   Cat cat; // объявление переменной, ссылающейся на объект (экземпляр) класса Cat  
   cat = new Cat  // создание нового объекта (экземпляра) класса Cat 
   ```
**Источник.** https://coderoad.ru/2885385/В-чем-разница-между-экземпляром-и-объектом
https://docs.oracle.com/javase/specs/jls/se9/html/jls-4.html#jls-4.3.1  

35: Назовите три этапа создания экземпляра класса.  
**Ответ.** Создание объекта состоит из трёх этапов:

а) Декларация  
Декларирование переменной типа класса с уникальным именем.  
б) Инстанциация  
Создание нового объекта с использованием ключевого слова ‘new’.  
в) Инициализация  
Вызов конструкторов, который идёт после ключевого слова ‘new’.  
**Источник.** https://proselyte.net/tutorials/java-core/classes-and-objects/  

36: Охарактеризуйте отношение композиции между классами? Как оно реализуется?  
**Ответ.** Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже. Такие описания всегда несколько условны, но тем не менее.  
**Источник.**  https://java-course.ru/begin/relations/  

37: Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами. 
**Ответ.**  В данном случае необходимо в качестве возвращаемого значения использовать массив. Например:  
```java
public int[] createArray(int size) {
       int[] myArray = new int[size]; 
       for(int i=0; i<size; i++) {  
           myArray[i] = i;  
       }  
       return myArray;  
   }  
   ```
Также допускается передача параметров с помощью объекта класса, хранящего два значения одного примитивного типа.  

38: Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.
Предложите способы и подтвердите примерами.  
**Ответ.** Создать класс, представляющий результат, который необходимо вернуть, и вернуть экземпляр этого класса. Дать классу значимое имя. Преимущества этого подхода-безопасность типов, и это сделает программу намного проще для понимания. Пример:  
```java
final class MyResult {
   private final int first;
   private final String second;

   public MyResult(int first, String second) {
       this.first = first;
       this.second = second;
   }

   public int getFirst() {
       return first;
   }

   public String getSecond() {
       return second;
   }
   }

   // ...

   public static MyResult something() {
       int number1 = 1;
       String number2 = “2”;

       return new MyResult(number1, number2);
   }

   public static void main(String[] args) {
       MyResult result = something();
       System.out.println(result.getFirst() + result.getSecond());
   }
   ```

39: Что такое иммутабельный объект?
Опишите 2 способа создания иммутабельных объектов.
Подсказка. Способ 1 - класс материала в classes2.
Какой альтернативный?
Подсказка - ключевое слово final для полей не использовать.
Создайте иммутабельный класс для вещества по альтернативному способу.  
**Ответ.** Объект считается неизменным, если его состояние не может измениться после создания. Максимальное использование неизменяемых объектов широко признано разумной стратегией создания простого и надежного кода. Неизменяемые объекты особенно полезны в параллельных приложениях. Поскольку они не могут изменить состояние, они не могут быть повреждены вмешательством потоков или наблюдаться в несогласованном состоянии.
Следующие правила определяют простую стратегию создания неизменяемых объектов. Не предоставляйте методы «установки» - методы, которые изменяют поля или объекты, на которые ссылаются поля. Сделайте все поля final. Альтернативный способ – не создавать методов, способных изменять внутреннее состояние объекта.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html
https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html   
Пример иммутабельного класса для вещества по альтернативному способу:  
```java
 public class Material {
        private  String name;
        private  double density;
        Material();
        Material(String name, double density){
            this.name = name;
            this.density = density;
        }
        //getters
        public String getName(){
            return name;
        }
        public double getDensity(){
            return density;
        }
    }
  
   ```

40: Даны 2 класса.
final class Material {
private final String name;
private final double density;
...
}
class Runner {
private static void printMaterial(final Material material) {
System.out.println(material);
}
public static void main(String[] args) {
Material steel = new Material("steel",7850);
printMaterial(steel);
}
}
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)?
Какой пример можно использовать для обоснования ответа?  
**Ответ.**  Новый объект не создается, имеется доступ к объекту new Material("steel",7850). Модификатор final запрещает изменение аргумента, однако, с помощью методов класса его можно изменить. В данном примере изменить данные объекта нельзя, т.к. поля объявлены final. Если поля будут без данного модификатора, их можно изменить с помощью методов класса. Какой пример можно использовать для обоснования ответа? Пример:  
```java
final class Material {
        private  String name;
        private  double density;
        public void setName(String Name){
            this.name = name;
        }
    ...
    }
    class Runner {
    private static void printMaterial(final Material material) {
        System.out.println(material);
        material.setName("Steel");
        System.out.println(material);
    }
    public static void main(String[] args) {
        Material steel = new Material("steel",7850);
        printMaterial(steel);
    }
    }
   ```

41: Класс для комплексного числа содержит два поля:
class Complex {
private double re;
private double im;
…
}
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.
**Ответ.**  
```java
class Complex {
        private double re;
        private double im;
        Complex ();
        Complex (double re, double im){
            this.re = re;
            this.im = im;
        }
        public Complex plus(Complex complex){
            double re = complex.re + this.re;
            double im = complex.im + this.im;
            return new Complex(re, im);
        }
        public Complex add(Complex complex){
                re += complex.re;
                im += complex.im;
            return this;
        }
    }

    public class Runner{
    public static void main(String[] args){
        Complex complex = new Complex(12.1, 15,2);
        Complex complexTwo  = new Complex(11.1, 12,2);
        complex.add(complexTwo);
        Complex complexThree = complex.plus(complexTwo);
    }
    }
   ```
Реализуйте эти же методы при условии, что класс Complex является иммутабельным.  
```java
class Complex {
        private final double re;
        private final  im;
        Complex ();
        Complex (double re, double im){
            this.re = re;
            this.im = im;
        }
        public Complex plus(Complex complex){
            double re = complex.re + this.re;
            double im = complex.im + this.im;
            return new Complex(re, im);
        }
    }

    public class Runner{
    public static void main(String[] args){
        Complex complex = new Complex(12.1, 15,2);
        Complex complexTwo  = new Complex(11.1, 12,2);
        Complex complexThree = complex.plus(complexTwo);
    }
    }
   ```

42: Для чего предназначен метод toString()?
В каких случаях он вызывается?
**Ответ.** toString() метод в Java используется для предоставления ясной и достаточной информации об объекта Object в удобном для человека виде. Правильное переопределение метода toString() может помочь в ведении журнала работы и в отладке Java программы предоставляя ценную и важную информацию. Поскольку toString() определен в java.lang.Object класса и его реализация по умолчанию не предоставляет много информации, всегда лучшей практикой является переопределение данного метода в классе-потомке.  
**Источник.**  https://javarush.ru/groups/posts/695-10-podskazok-po-pereopredeleniju-metoda-tostring-v-java-chastjh-1  

43: Как реализован метод toString() в классе Object?  
**Ответ.**  
```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
   ```
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html  

44: Для чего предназначен метод equals()?
В каких случаях он вызывается?  
**Ответ.** Метод equals() необходим в Java для подтверждения или отрицания того факта, что два объекта одного происхождения являются логически равными. То есть, сравнивая два объекта, программисту необходимо понять, эквивалентны ли их значимые поля.  
**Источник.** https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam  

45: Как реализован метод equals() в классе Object?  
**Ответ.**  
```java
 public boolean equals(Object obj) {
        return (this == obj);
    }
   ```

46: В чем различие между методом equals() и операции ==?
В каких случаях применение метода equals() и операции == эквивалентно?  
**Ответ.** В Java сравнение объектов производится с помощью метода equals() класса Object. Этот метод сравнивает содержимое объектов и выводит значение типа boolean. Значение true - если содержимое эквивалентно, и false — если нет.

Операция == не рекомендуется для сравнения объектов в Java. Дело в том, что при сравнении объектов, операция == вернет true лишь в одном случае — когда ссылки указывают на один и тот же объект. В данном случае не учитывается содержимое переменных класса.

При создании пользовательского класса, принято переопределять метод equals() таким образом, что бы учитывались переменные объекта.
Для примитивных типов это эквивалентные операции. Отличия equals() от операции == в классе Object нет. Однако, нужно не забывать, что, если объект ни на что не ссылается(null), то вызов метода equals этого объекта приведет к NullPointerException. Также нужно помнить, что при сравнении объектов оба они могут быть null и операция obj1 == obj2 в данном случае будет true, а вызов equals приведет к исключению NullPointerException. Как мы видим, при помощи операции == сравниваются ссылки на объекты. Но мы можем переопределять метод equals, тем самым задавая логику сравнения двух объектов.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/method-equals  
http://www.quizful.net/interview/java/equals-equality-difference


47: Eclipse в стандартной конфигурации генерирует начало метода equals() следующим образом:
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;
С чем связаны данные проверки, которые кажутся лишними?  
**Ответ.**  Метод `equals` класса Object реализует наиболее разборчивых возможное отношение эквивалентности на объектах; то есть для любых ненулевых ссылочных значений x и y этот метод возвращает true тогда и только тогда, когда x и y ссылается на один и тот же объект ( x == y имеет значение true).
if (obj == null) — для любой ненулевой ссылки на значение x, выражение x.equals(null) должно возвращать false — выполнение эанного условия помогает избежать NullPointerException. При переопределении метода equals() должны выполняться соглашения, предусмотренные спецификацией языка Java, т.е. рефлексивность, симметричность, транзитивность, непротиворечивость, сравнение с литералом null.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)  

48: Что такое garbage collection?  
**Ответ.**    
Сборка мусора в Java — это процесс, с помощью которого программы Java автоматически управляют памятью. Java-программы компилируются в байт-код, который запускается на виртуальной машине Java (JVM).
Когда Java-программы выполняются на JVM, объекты создаются в куче, которая представляет собой часть памяти, выделенную для них.
Пока Java-приложение работает, в нем создаются и запускаются новые объекты. В конце концов некоторые объекты перестают быть нужны. Можно сказать, что в любой момент времени память кучи состоит из двух типов объектов.
Живые — эти объекты используются, на них ссылаются откуда-то еще.
Мертвые — эти объекты больше нигде не используются, ссылок на них нет.
Сборщик мусора находит эти неиспользуемые объекты и удаляет их, чтобы освободить память.  
**Источник.** https://medium.com/nuances-of-programming/%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B0-%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0-%D0%B2-java-%D1%87%D1%82%D0%BE-%D1%8D%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%B2-jvm-25bb2570b44c

49: Перечислите случаи, когда JVM отдает управление на garbage collector.  
**Ответ.**  
Имеется несколько подходов к очистке памяти, которые в совокупности определяют принцип функционирования Garbage Collection.

а) `Copying collectors`  
При использовании «Copying collectors» область памяти делится на две части : в одной части размещаются объекты, а вторая часть остается чистой. На время очистки мусора приложение останавливает работу и запускается сборщик мусора, который находит в первой области объекты со ссылками и переносит их во вторую (чистую) область. После этого, первая область очищается от оставшихся там объектов без ссылок, и области меняются местами.  
б) `Mark-and-sweep`  
При использовании «mark-and-sweep» все объекты размещаются в одном сегменте памяти. Сборка мусора также приостанавливает приложение, и Garbage Collection проходит по дереву объектов, помечая занятые ими области памяти, как «живые». После этого, все не помеченные участки памяти сохраняются в «free list», в которой будут, после завершения сборки мусора, размещаться новые объекты.   
в) `Serial Garbage Collection`  
Относится к одним из первых сборщиков мусора в HotSpot VM. Во время работы этого сборщика приложение приостанавливается и возобновляет работу только после прекращения сборки мусора. В Serial Garbage Collection область памяти делится на две части («young generation» и «old generation»), для которых выполняются два типа сборки мусора :  

minor GC – частый и быстрый c областью памяти «young generation»;  
mark-sweep-compact – редкий и более длительный c областью памяти «old generation».  
**Источник.** https://java-online.ru/garbage-collection.xhtml  

50: Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?  
**Ответ.** JVM обычно запускает сборщик мусора при низком уровне свободной памяти. Но работа сборщика мусора не гарантирует, что всегда будет оставаться достаточно свободной памяти.
Если памяти недостаточно даже после восстановления, JVM генерирует исключение OutOfMemoryError. Обратите внимание, что перед генерированием исключения JVM обязательно запускает сборщик мусора как минимум 1 раз.
Вы можете запросить запуск сборщика мусора, но вы не можете принудительно задавать это действие.  
**Запрос запуска сборщика мусора**  
Для запроса вы можете вызвать один из следующих методов:  
```java
System.gc()
Runtime.getRuntime().gc()
```
**Источник.** https://javarush.ru/groups/posts/917-sborka-musora  

51: Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти?
Обоснуйте ответ.  
**Ответ.** Нет, всегда возможно, что вы попытаетесь выделить больше памяти, чем доступно.
Автоматическая сборка мусора означает только то, что мусор (т. е. неиспользуемая память) автоматически собирается (т. е. утилизируется для дальнейшего использования). Если вы сохраняете ссылки на него, это не мусор и не собирается.  

52: Для чего предназначен метод finalize()?
Какой недостаток у метода?  
**Ответ.** Java-технология позволяет использовать метод finalize() (финализировать), чтобы произвести необходимую очистку перед тем, как сборщик мусора извлекает объект из памяти. Этот метод вызывается для объекта сборщиком мусора, когда сборщик мусора вычисляет, что ссылок к объекту больше нет. Это описано в классе Object, а значит, это наследуется всеми классами.  
Если незарегистрированное исключение генерируется методом finalize(), то исключение игнорируется и финализация этого объекта прекращается.

Метод finalize() будет активизирован только один раз за время существования объекта.

Возможно использование метода finalize() любого объекта, чтобы защитить его от утилизации. Но в этом случае сборщик мусора уже не активирует finalize() для этого объекта.

Метод finalize() всегда будет активизирован один раз перед тем, как объект будет удалён сборщиком мусора. Однако, возможно, что метод finalize() не будет активизирован для данного объекта за всё время его существования, так как он может не подлежать утилизации.  
**Источник.** https://javarush.ru/groups/posts/917-sborka-musora

53: Для чего предназначены оболочечные классы?
Как они называются на инглише?
**Ответ.** Примитивы и их аналоги, классы оболочки, существуют параллельно, потому что у каждого есть преимущества.

Например, обычный int занимает меньше места, и если нет необходимости проводить над ним особые операции, Ваш компьютер будет работать быстрее.

В свою очередь, с помощью класса-оболочки Integer можно выполнять специальные операции - например, перевести текст в число (с помощью метода .parseInt() для Integer-а ). Если попробовать сделать это с помощью кода самому придется изрядно повозиться.

Integer и int можно сравнить с компьютером и записной книжкой:
Компьютер, безусловно, может больше, чем блокнот - но Вы не будете целый день носить с собой три килограмма для того, чтобы сделать несколько заметок?

Кроме того, есть ситуации, когда нельзя использовать объекты, или наоборот, когда можно использовать только объекты.  

"wrapper" (с англ. "обертка, упаковка").  
**Источник.** https://vertex-academy.com/tutorials/ru/klassy-obolochki-v-java/  

54: В чем преимущество примитивных типов перед соответствующими оболочечными классами?  
**Ответ.** Между примитивными и упакованными примитивными типами есть три основных различия. Во-первых, у примитивных типов есть только значения, в то время как у упакованных примитивных типов имеется еще и идентичность (identities), отличная от их значений. Иными словами, два экземпляра упакованных примитивных типов могут иметь одинаковые значения, но разные идентичности. Во-вторых, примитивные типы имеют только полнофункциональные значения, в то время как каждый упакованный примитивный тип имеет одно нефункциональное значение — null — в дополнение ко всем функциональным значениям соответствующего примитивного типа. И наконец, примитивные типы более эффективны с точки зрения потребления памяти и времени работы, чем упакованные примитивные типы. Все эти различия могут привести к реальным проблемам при неосторожном использовании упакованных примитивных типов.  
**Источник.** Источник. Дж. Блох “Java эффективное программирование” стр. 334

55: Что такое autoboxing и unboxing?  
**Ответ.**  В Java определен процесс автоматической инкапсуляции данных базовых типов в соответствующие объекты оболочки и обратно (автоупаковка/автораспаковка). При этом нет необходимости в явном создании соответствующего объекта с использованием методов. Автораспаковка — процесс извлечения из объекта-оболочки значения базового типа. Вызовы методов intValue(), doubleValue() и им подобных для преобразования объектов в значения базовых типов становятся излишними.  
**Источник.** И. Блинов Java from Epam стр. 46-47

56: Дан код:
Integer a = 3, b =7;
Long c = a + b;
Перечислите все операции, где задействованы autoboxing и unboxing.  
**Ответ.**  
В данном случае верно будет Long c = (long) (a + b);,  
где сначала происходит:  
сложение примитивов из оболочек (a + b),  
а после:  
полученный примитив упаковывается в оболочку Long c a = 3, b =7, a + b – autoboxing c = - unboxing.  

57: Дан корректный раннер-класс.
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()?
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?  
**Ответ.** Компилятор не будет оповещать разработчика о какой-либо проблеме, но результатом выполнения станет ошибка:  
`Error: Main method is not static in class Runner, please define the main method as: public static void main(String[] args)`  

58: Дан класс.
class Runner {
public static void main(String[] args) {
System.out.println("Hello, world!");
}
}
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
I am java.
Hello, world!  
**Ответ.** 
```java
class Runner {
   static {
      System.out.println("I am java.");
   }
   public static void main(String[] args) {
      System.out.println("Hello, world!");
   }
}
```
