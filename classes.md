**Theory classes**

1: Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?  
**Ответ.**  Модификаторы уровня доступа определяют, могут ли другие классы использовать определенное поле или вызывать определенный метод. Есть два уровня контроля доступа: На верхнем уровне `public-` или `package-private` (без явного модификатора).  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html  

2: Что является членами класса?  
**Ответ.** Класс в Java - это шаблон для создания объекта, а объект - это экземпляр класса. Класс определяет структуру и поведение, которые будут совместно использоваться набором объектов. Класс содержит переменные и методы, которые называются элементами класса, членами класса.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/oop-klassi-metodi  

3: Что еще можно определить в классе кроме членов?
**Ответ.** Конструктор класса, статический блок инициализации класса, блок инициализации экземпляра.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.6

4: Какие уровни доступа есть у членов класса?  
**Ответ.**  
   `public` (общедоступный);  
   `protected` (защищенный);  
   `default` (также называемый пакетным доступом);  
   `private` (закрытый).  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик стр. 68-69  

5: Какие модификаторы необходимы для определения константы:
а) класса,
б) экземпляра класса?  
**Ответ.**  
а) `static final`  
б) Модификатор `final`  

6: Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
class SomeClass {
private int a;
private final int b;
private static int c;
private static final int D;
...
}
7: Как можно назвать данные поля в зависимости от комбинации модификаторов `static` и `final`?  
**Ответ.**  
   private int a; (приватное поле)  
   private final int b; (приватное финальное поле)  
   private static int c; (приватное статическое поле)  
   private static final int D; (приватное статическое финальное поле)  

8: Может ли класс не иметь ни одного конструктора? Почему?  
**Ответ.** Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (default constructor), который будет пустым и не делает ничего, кроме вызова конструктора суперкласса.  
**Источник.**  https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

9: Перечислите отличия конструктора от метода.  
**Ответ.** Конструктор - это специальный метод, который вызывается при создании нового объекта. В отличие от метода, конструктор никогда ничего не возвращает. Конструктор определяет действия, выполняемые при создании объекта класса, и является важной частью класса. Как правило, программисты стараются явно указать конструктор.  
**Источник.** http://developer.alexanderklimov.ru/android/java/constructor.php  

10: Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?  
**Ответ.**  Для этого используется ключевое слово this, после которого в круглых скобках указываем параметры для соотвествующего конструктора.  
Вы можете вызвать один конструктор из другого в том же классе, или в надклассе, со следующими ограничениями:  
Вызываемый конструктор должен быть в первой строке кода в вызывающем конструкторе.  
Вложенный конструктор не может иметь никакой явной или неявной ссылки на "this". Таким образом, вы не можете попасть во внутренний класс.  
**Источник.** https://javarush.ru/groups/posts/793-vihzov-konstruktora-iz-konstruktora  

11: Как и в каком месте можно вызвать конструктор суперкласса?  
**Ответ.** Конструктор суперкласса (базового класса) может быть вызван из подкласса (производного класса). Этот вызов осуществляется с помощью ключевого слова super. Вызов конструктора суперкласса должен быть осуществлен в теле конструктора подкласса первым.  
**Источник.** https://www.bestprog.net/ru/2019/06/07/java-inheritance-a-reference-to-a-subclass-object-calling-the-superclass-constructor-the-keyword-super-ru/  

12: Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?  
**Ответ.** Если конструктор не создается, автоматически создается пустой конструктор по умолчанию .

Если какой-либо конструктор явно не вызывает super или этот конструктор в качестве своего первого оператора, автоматически добавляется вызов `super()` .

Всегда.  

13: Можно ли одновременно использовать конструкции `this()` и `super()` в одном и том же конструкторе?
Обоснуйте ответ.  
**Ответ.** Внутри конструктора `this` и `super` должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и `this()`, и `super()`.  
**Источник.** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java  

14: Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?  
**Ответ.**  Создание чего-то private не означает, что никто не сможет получить к нему доступ. Это просто означает, что никто за пределами класса не может получить к нему доступ. Поэтому конструктор private тоже полезен.
Одним из использования конструктора private является использование одноэлементных классов. Класс singleton - это тот, который ограничивает количество создания объектов одним. Используя конструктор private, мы можем гарантировать, что за один раз может быть создано не более одного объекта.  

15: Какие модификаторы может иметь конструктор?  
**Ответ.** Конструкторы могут быть public, private, protected или default (вообще нет модификатора доступа).  

16: Конструктор принадлежит классу или экземпляру класса?  
**Ответ.** Конструктор принадлежит классу. Но в то же время, конструктор вызывается в контексте экземпляра.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.3

17: Можно ли наследовать конструктор?  
Если да, то приведите примеры.  
**Ответ.** подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса. в Java конструкторы не являются членами, поэтому они не наследуются подклассом, но конструктор суперкласса может быть вызван из подкласса.  
**Источник.** http://proglang.su/java/inheritance  

18: Какой тип возвращаемого конструктором значения?  
**Ответ.** Конструктор не должен иметь тип возврата. По определению, если метод имеет тип возвращаемого значения, он не является конструктором.  

19: Дан класс.
class Null {
//фрагмент 1
Null Null() {
return null;
}
//фрагмент 2
Null() {
return null;
}
}
В каком фрагменте ошибка компиляции?
Удалите этот фрагмент полностью.
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.  
**Ответ.**  Второй фрагмент является конструктором. Он ничего не должен возвращать, поэтому он неверен. Первый фрагмент верен, но согласно соглашению, называть методы так же, как и класс неверно, так именуются конструкторы. Этот фрагмент вернет `null`.  
```java
public static void main(String[] args) {
  Null object = new Null();
  object = object.Null();
  System.out.println(object); // null
}
```

20: Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?  
**Ответ.** Конструктор не имеет возвращаемого значения. Если при определении конструктора указан тип возвращаемого значения (фрагмент 1) , то он считается методом Пример:  
```java
class Null {  
       //фрагмент 1  
       Null Null() {  
           return null;  
       }  
   } 
    
   public class Runner {
       public static void main(String[] args) {
           Null exampleNull  = new Null();
           System.out.print(exampleNull.Null());
       }

   }
   ```
Результат работы программы: `null`.  

21: Дан класс.
class Name {
String name;
Name() {
this(makeRandomName());
}
Name(String name) {
super();
this.name = name;
}
String makeRandomName() {
int k = (int) (Math.random() * 3);
String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
return name;
}
public String toString() {
return name;
}
public static void main(String[] args) {
System.out.println(new Name());
}
}
Объясните причину ошибки компиляции.
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.  
**Ответ.**  Чтобы сработал данный код, метод makeRandomName() должен быть статичным, т.к. на этапе работы кода из конструктора объект еще не создан, и обратиться к данному методу нельзя. 1 способ - установить для метода модификатор static. 2 способ устранения — провести прямую инициализацию name в непараметризованном конструкторе:  
```java
name = makeRandomName();
```
  
22: Дан класс.
class Int {
int i;
void inc(Int param) {
//param = new Int();
param.i++;
}
public static void main(String[] args) {
Int obj = new Int();
obj.inc(obj);
System.out.println(obj.i);
}
}
Изменится ли результат, если убрать комментарий?
Объясните, почему?  
**Ответ.** Если убрать комментарий, то в этой строке кода создастся новый локальный объект Int(), значение которого будет увеличено на +1, при этом передающийся в метод аргумент останется неизменным, т.к. param примет ссылку на новый объект, и будет работать уже с ним, а с переданным аргументом не будет производиться никаких операций.  

23: В чем смысл конструкции this?
Перечислите случаи, когда используется конструкция this.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?  
**Ответ.** Каждый экземпляр класса (объект) имеет неявную ссылку this на себя, которая передается также неявно и нестатическим методам класса. После этого каждый метод «знает», какой объект его вызвал. Вместо обращения к атрибуту accountId в методах можно писать this.accountId, хотя и не обязательно, так как записи accountId, this.accountId и Account.this. accountId равносильны. Но если в методе объявлена локальная переменная или параметр метода с таким же именем, как и поле класса, то для обращения к полю класса использование this обязательно. Без использования указателя обращение всегда будет производиться к локальной переменной, так как просто не существует другого способа ее идентификации. Наиболее частая причина использования ключевого слова this заключается в том, что поле затенено параметром метода или конструктора. Изнутри конструктора вы также можете использовать ключевое слово this для вызова другого конструктора в том же классе. Это называется явным вызовом конструктора . Например, класс Point был написан так:  
```java
public class Point {
       public int x = 0;
       public int y = 0;

       //constructor
       public Point(int a, int b) {
           x = a;
           y = b;
       }
   }
   ```  
но это можно было бы написать так:  
```java
public class Point {
       public int x = 0;
       public int y = 0;
   
       //constructor
       public Point(int x, int y) {
           this.x = x;
           this.y = y;
       }
   }
   ```
**Источник.** И. Блинов Java from Epam стр. 71
https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html  

24: Можно ли присвоить null ссылочной переменной this?  
**Ответ.**  Нет, нельзя. В Java левая часть оператора присваивания должен быть переменной. this — это специальное ключевое слово, которое всегда дает текущий экземпляр класса. Это не любая переменная. Точно также, null нельзя присвоить переменной, используя ключевое слово super или любое другое подобное.  
**Источник.**  https://javarush.ru/groups/posts/780-java-core-voprosih-k-sobesedovaniju-ch-3  

25: Перечислите случаи, когда используется статический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** Блок статической инициализации - это обычный блок кода, заключенный в фигурные скобки { }, и которому предшествует static ключевое слово. Вот пример:  
```java
static {  
       // любой код, необходимый для инициализации, идет сюда  
   } 
   ```  
Класс может иметь любое количество статических блоков инициализации, и они могут появляться в любом месте тела класса. Система времени выполнения гарантирует, что статические блоки инициализации вызываются в том порядке, в котором они появляются в исходном коде. Есть альтернатива статическим блокам - вы можете написать приватный статический метод.Методы класса не могут напрямую обращаться к переменным экземпляра или методам экземпляра - они должны использовать ссылку на объект. Кроме того, методы класса не могут использовать ключевое слово this, поскольку нет экземпляра, на который можно было бы ссылаться `this`.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html   

26: Перечислите случаи, когда используется логический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** При описании класса могут быть использованы логические блоки. Логическим блоком называется код, заключенный в фигурные скобки и не принадлежащий ни одному методу текущего класса, например:  
```java
{ /* code */ }  
   static { /* code */ }  
   ```
Логические блоки чаще всего используются в качестве инициализаторов полей, но могут содержать вызовы методов и обращения к полям текущего класса. При создании объекта класса они вызываются последовательно, в порядке размещения, вместе с инициализацией полей как простая последовательность операторов, и только после выполнения последнего блока будет вызван конструктор класса. Операции с полями класса внутри логического блока до явного объявления этого поля возможны только при использовании ссылки this, представляющей собой ссылку на текущий объект На практике статические логические блоки могут применяться для проверки и инициализации базовых параметров, необходимых для функционирования приложения или класса. Нестатичексие логические блоки могут применяться для проверки и инициализации параметров конкретного объекта и для сокращения количества кода, если одинаковый код присутствует в каждом конструкторе.  
**Источник.** И. Блинов Java from Epam стр. 85

27: Что входит в сигнатуру метода?  
**Ответ.** В более общем смысле, объявления методов состоят из шести компонентов в следующем порядке: Модификаторы доступа. Тип возврата - тип данных значения, возвращаемого методом, или void если метод не возвращает значение. Имя метода - правила для имен полей применяются также к именам методов, но соглашение немного отличается. Список параметров в скобках-разделенный запятыми список входных параметров, которым предшествуют их типы данных, заключенные в скобки,(). Если параметров нет, необходимо использовать пустые скобки. Список исключений Тело метода, заключенное в фигурные скобки - это код метода, включая объявление локальных переменных.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html  

28: Что значит ключевое слово native?  
**Ответ.**  Если к методу применяется ключевое слово native, то это означает, что метод будет реализован с использованием собственного кода, написанного на другом языке (например, C или C ++) через JNI (собственный интерфейс JAVA).  
**Источник.** https://ru.education-wiki.com/8247106-native-keyword-in-java  

29: Дан код.
public class BusinessTrip {
…
public String bynToStr(int value) {
return (value / 100) + "." + (value / 10 % 10) + (value % 10);
}
}
Есть ли в нем семантическая ошибка?
Если да, то обоснуйте.  
**Ответ.** Если метод предполагает использование только внутри данного класса, то он должен быть private static, т.к. по его логике он принимает значение вне зависимоти от данных экземпляра класса. Если метод может быть использован вне данного класса, то его стоит определить в отдельном утилитном классе и так же сделать статическим.  

30: Дан код.
public class Utility {
private Utility() {
}
public String bynToStr(int value) {
return (value / 100) + "." + (value / 10 % 10) + (value % 10);
}
}
Есть ли в нем семантическая ошибка?
Если да, то предложите альтернативные варианты.  
**Ответ.** сделав метод статичным мы избавимся от проблемы, однако, стоит отметить другое: для вызова bynToStr() экземпляр класса не нужен, а нестатический метод в утилитном классе — это антипаттерн.  

31: К каким данным можно обратиться в статическом методе?  
**Ответ.** Модификатор static в Java напрямую связан с классом. Если поле статично, значит оно принадлежит классу, если метод статичный — аналогично: он принадлежит классу. Исходя из этого, можно обращаться к статическому методу или полю, используя имя класса. Например, если поле count статично в классе Counter, значит, вы можете обратиться к переменной запросом вида: Counter.count.  
**Источник.** https://javarush.ru/groups/posts/modifikator-static-java

32: Почему нельзя объявить статическое поле внутри метода?  
**Ответ.** Внутри метода объявляются только локальные переменные метода, доступные только внутри метода.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html

33: Перечислите, какой код в классе можно выполнить до создания объекта.  
**Ответ.**  
а) Статический блок инициализации.  
б) Логический блок инициализации.  
в) Статические члены класса.  
**Источник.**  И. Блинов Java from Epam стр. 81
https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4

34: В чем различие между объектом и экземпляром класса?  
**Ответ.** Java объект - чуть более широкое понятие чем экземпляр класса, включает в себя такие понятия, как “экземпляр класса” и “массив”.  
```java
public class Cat  // объявление класса Cat  
   Cat cat; // объявление переменной, ссылающейся на объект (экземпляр) класса Cat  
   cat = new Cat  // создание нового объекта (экземпляра) класса Cat 
   ```
**Источник.** https://coderoad.ru/2885385/В-чем-разница-между-экземпляром-и-объектом
https://docs.oracle.com/javase/specs/jls/se9/html/jls-4.html#jls-4.3.1  

35: Назовите три этапа создания экземпляра класса.  
**Ответ.** Создание объекта состоит из трёх этапов:

а) Декларация  
Декларирование переменной типа класса с уникальным именем.  
б) Инстанциация  
Создание нового объекта с использованием ключевого слова ‘new’.  
в) Инициализация  
Вызов конструкторов, который идёт после ключевого слова ‘new’.  
**Источник.** https://proselyte.net/tutorials/java-core/classes-and-objects/  

36: Охарактеризуйте отношение композиции между классами? Как оно реализуется?  
**Ответ.** Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже. Такие описания всегда несколько условны, но тем не менее.  
**Источник.**  https://java-course.ru/begin/relations/  

37: Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами. 
**Ответ.**  В данном случае необходимо в качестве возвращаемого значения использовать массив. Например:  
```java
public int[] createArray(int size) {
       int[] myArray = new int[size]; 
       for(int i=0; i<size; i++) {  
           myArray[i] = i;  
       }  
       return myArray;  
   }  
   ```
Также допускается передача параметров с помощью объекта класса, хранящего два значения одного примитивного типа.  

38: Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.
Предложите способы и подтвердите примерами.  
**Ответ.** Создать класс, представляющий результат, который необходимо вернуть, и вернуть экземпляр этого класса. Дать классу значимое имя. Преимущества этого подхода-безопасность типов, и это сделает программу намного проще для понимания. Пример:  
```java
final class MyResult {
   private final int first;
   private final String second;

   public MyResult(int first, String second) {
       this.first = first;
       this.second = second;
   }

   public int getFirst() {
       return first;
   }

   public String getSecond() {
       return second;
   }
   }

   // ...

   public static MyResult something() {
       int number1 = 1;
       String number2 = “2”;

       return new MyResult(number1, number2);
   }

   public static void main(String[] args) {
       MyResult result = something();
       System.out.println(result.getFirst() + result.getSecond());
   }
   ```

39: Что такое иммутабельный объект?
Опишите 2 способа создания иммутабельных объектов.
Подсказка. Способ 1 - класс материала в classes2.
Какой альтернативный?
Подсказка - ключевое слово final для полей не использовать.
Создайте иммутабельный класс для вещества по альтернативному способу.  
**Ответ.** Объект считается неизменным, если его состояние не может измениться после создания. Максимальное использование неизменяемых объектов широко признано разумной стратегией создания простого и надежного кода. Неизменяемые объекты особенно полезны в параллельных приложениях. Поскольку они не могут изменить состояние, они не могут быть повреждены вмешательством потоков или наблюдаться в несогласованном состоянии.
Следующие правила определяют простую стратегию создания неизменяемых объектов. Не предоставляйте методы «установки» - методы, которые изменяют поля или объекты, на которые ссылаются поля. Сделайте все поля final. Альтернативный способ – не создавать методов, способных изменять внутреннее состояние объекта.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html
https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html   
Пример иммутабельного класса для вещества по альтернативному способу:  
```java
 public class Material {
        private  String name;
        private  double density;
        Material();
        Material(String name, double density){
            this.name = name;
            this.density = density;
        }
        //getters
        public String getName(){
            return name;
        }
        public double getDensity(){
            return density;
        }
    }
  
   ```

40: Даны 2 класса.
final class Material {
private final String name;
private final double density;
...
}
class Runner {
private static void printMaterial(final Material material) {
System.out.println(material);
}
public static void main(String[] args) {
Material steel = new Material("steel",7850);
printMaterial(steel);
}
}
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)?
Какой пример можно использовать для обоснования ответа?  
**Ответ.**  Новый объект не создается, имеется доступ к объекту new Material("steel",7850). Модификатор final запрещает изменение аргумента, однако, с помощью методов класса его можно изменить. В данном примере изменить данные объекта нельзя, т.к. поля объявлены final. Если поля будут без данного модификатора, их можно изменить с помощью методов класса. Какой пример можно использовать для обоснования ответа? Пример:  
```java
final class Material {
        private  String name;
        private  double density;
        public void setName(String Name){
            this.name = name;
        }
    ...
    }
    class Runner {
    private static void printMaterial(final Material material) {
        System.out.println(material);
        material.setName("Steel");
        System.out.println(material);
    }
    public static void main(String[] args) {
        Material steel = new Material("steel",7850);
        printMaterial(steel);
    }
    }
   ```

41: Класс для комплексного числа содержит два поля:
class Complex {
private double re;
private double im;
…
}
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.
**Ответ.**  
```java
class Complex {
        private double re;
        private double im;
        Complex ();
        Complex (double re, double im){
            this.re = re;
            this.im = im;
        }
        public Complex plus(Complex complex){
            double re = complex.re + this.re;
            double im = complex.im + this.im;
            return new Complex(re, im);
        }
        public Complex add(Complex complex){
                re += complex.re;
                im += complex.im;
            return this;
        }
    }

    public class Runner{
    public static void main(String[] args){
        Complex complex = new Complex(12.1, 15,2);
        Complex complexTwo  = new Complex(11.1, 12,2);
        complex.add(complexTwo);
        Complex complexThree = complex.plus(complexTwo);
    }
    }
   ```
Реализуйте эти же методы при условии, что класс Complex является иммутабельным.  
```java
class Complex {
        private final double re;
        private final  im;
        Complex ();
        Complex (double re, double im){
            this.re = re;
            this.im = im;
        }
        public Complex plus(Complex complex){
            double re = complex.re + this.re;
            double im = complex.im + this.im;
            return new Complex(re, im);
        }
    }

    public class Runner{
    public static void main(String[] args){
        Complex complex = new Complex(12.1, 15,2);
        Complex complexTwo  = new Complex(11.1, 12,2);
        Complex complexThree = complex.plus(complexTwo);
    }
    }
   ```

42: Для чего предназначен метод toString()?
В каких случаях он вызывается?
**Ответ.** toString() метод в Java используется для предоставления ясной и достаточной информации об объекта Object в удобном для человека виде. Правильное переопределение метода toString() может помочь в ведении журнала работы и в отладке Java программы предоставляя ценную и важную информацию. Поскольку toString() определен в java.lang.Object класса и его реализация по умолчанию не предоставляет много информации, всегда лучшей практикой является переопределение данного метода в классе-потомке.  
**Источник.**  https://javarush.ru/groups/posts/695-10-podskazok-po-pereopredeleniju-metoda-tostring-v-java-chastjh-1  

43: Как реализован метод toString() в классе Object?  
**Ответ.**  
```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
   ```
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html  

44: Для чего предназначен метод equals()?
В каких случаях он вызывается?  
**Ответ.** Метод equals() необходим в Java для подтверждения или отрицания того факта, что два объекта одного происхождения являются логически равными. То есть, сравнивая два объекта, программисту необходимо понять, эквивалентны ли их значимые поля.  
**Источник.** https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam  

45: Как реализован метод equals() в классе Object?  
**Ответ.**  
```java
 public boolean equals(Object obj) {
        return (this == obj);
    }
   ```

46: В чем различие между методом equals() и операции ==?
В каких случаях применение метода equals() и операции == эквивалентно?

47: Eclipse в стандартной конфигурации генерирует начало метода equals() следующим образом:
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;
С чем связаны данные проверки, которые кажутся лишними?

48: Что такое garbage collection?

49: Перечислите случаи, когда JVM отдает управление на garbage collector.

50: Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?

51: Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти?
Обоснуйте ответ.

52: Для чего предназначен метод finalize()?
Какой недостаток у метода?

53: Для чего предназначены оболочечные классы?
Как они называются на инглише?

54: В чем преимущество примитивных типов перед соответствующими оболочечными классами?

55: Что такое autoboxing и unboxing?

56: Дан код:
Integer a = 3, b =7;
Long c = a + b;
Перечислите все операции, где задействованы autoboxing и unboxing.

57: Дан корректный раннер-класс.
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()?
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?

58: Дан класс.
class Runner {
public static void main(String[] args) {
System.out.println("Hello, world!");
}
}
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
I am java.
Hello, world!

59: Бонусное задание 1 (необязательное)
В задаче classes3 имеются два константных поля в классе покупки.
Им сразу присваиваются значения по умолчанию.
Например.
public class Purchase {
public final static String PRODUCT_NAME = "milk";
public final static int PRICE = 120;
...
}
Измените реализацию так, чтобы константы инициализировались значениями из текстового файла, находящемся в том же пакете, что и класс покупки. Имя файла - константа в классе покупки.
Если будет сбой с файлом или в нем будут недопустимые значения, то присвойте константам PRODUCT_NAME и PRICE значения по умолчанию.
Для этого же примера начало класса должно быть таким:
public class Purchase {
private static final String PRODUCT_NAME;
private static final int PRICE;
public static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";
private static final String DEFAULT_PRODUCT_NAME = "milk";
private static final int DEFAULT_PRICE = 120;
