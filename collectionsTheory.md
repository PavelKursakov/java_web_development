1: Дайте неформальное определение контейнера.  
**Ответ.** Коллекция, иногда называемая контейнером, — это просто объект, объединяющий несколько элементов в единое целое.
Коллекции используются для хранения, извлечения, обработки и передачи агрегированных данных.
Как правило, они представляют собой элементы данных, образующие естественную группу,
например покерную комбинацию (набор карт), почтовую папку (набор писем) или телефонный
справочник (сопоставление имен и телефонных номеров).  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

2: Дайте определение коллекции в `java`.  
**Ответ.** Коллекции — это хранилища или контейнеры, поддерживающие различные
способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, поддерживающих три основные операции:  
• добавление нового элемента в коллекцию;  
• удаление элемента из коллекции; • изменение элемента в коллекции.  
В качестве других операций могут быть реализованы следующие: заменить,
просмотреть элементы, подсчитать их количество и др.  
**Источник.** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 253  

3: Какой имеется в `java` контейнер, отличный от коллекций?  
Дайте ему определение.  
**Ответ.** Массив — это структура данных, в которой хранятся элементы одного типа.
Его можно представить, как набор пронумерованных ячеек, в каждую из которых можно поместить
какие-то данные (один элемент данных в одну ячейку).
Доступ к конкретной ячейке осуществляется через её номер.
Номер элемента в массиве также называют индексом.  
**Источник.** https://javarush.ru/groups/posts/massivy-java  

4: Дайте определение `Collections framework`?  
**Ответ.** `Java Collection Framework` —  это унифицированная архитектура для представления коллекций и управления ими.     
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

5: Какие разделы содержит `Collections framework`?  
Определите их, и для чего они предназначены?  
**Ответ.**  
а) Интерфейсы: это абстрактные типы данных, представляющие коллекции.
Интерфейсы позволяют управлять коллекциями независимо от деталей их представления.
В объектно-ориентированных языках интерфейсы обычно образуют иерархию.  
б) Реализации: это конкретные реализации интерфейсов коллекций.
По сути, это повторно используемые структуры данных.  
в) Алгоритмы: это методы, которые выполняют полезные вычисления, такие как поиск и сортировка,
над объектами, которые реализуют интерфейсы коллекций. Алгоритмы называются полиморфными :
то есть один и тот же метод может использоваться во многих различных реализациях соответствующего
интерфейса коллекции. По сути, алгоритмы — это повторно используемые функции.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

6: В чем преимущества использования `Collections Framework`  
**Ответ.**  
а) Сокращает усилия по программированию: Предоставляя полезные структуры данных и алгоритмы, Collections Framework позволяет вам сконцентрироваться на важных частях вашей программы, а не на низкоуровневой «сантехнике», необходимой для ее работы. Упрощая взаимодействие между несвязанными API, Java Collections Framework освобождает вас от написания объектов адаптера или кода преобразования для подключения API.  
б) Увеличивает скорость и качество программы: эта структура коллекций обеспечивает высокопроизводительные и высококачественные реализации полезных структур данных и алгоритмов. Различные реализации каждого интерфейса взаимозаменяемы, поэтому программы можно легко настраивать, переключая реализации коллекций. Поскольку вы освобождаетесь от рутинной работы по написанию собственных структур данных, у вас появляется больше времени для улучшения качества и производительности программ.  
в) Обеспечивает взаимодействие между несвязанными API: интерфейсы коллекций — это язык, с помощью которого API передают коллекции туда и обратно. Если мой API-интерфейс сетевого администрирования предоставляет набор имен узлов, а ваш инструментарий графического интерфейса пользователя ожидает набор заголовков столбцов, наши API-интерфейсы будут беспрепятственно взаимодействовать, даже если они были написаны независимо друг от друга.  
г) Сокращает усилия по изучению и использованию новых API: многие API естественным образом принимают коллекции на входе и предоставляют их на выходе. Раньше у каждого такого API был небольшой суб-API, предназначенный для управления его коллекциями. Между этими специальными API-интерфейсами коллекций было мало согласованности, поэтому вам приходилось изучать каждый из них с нуля, и при их использовании было легко сделать ошибки. С появлением стандартных интерфейсов коллекций проблема ушла.  
д) Сокращает усилия по разработке новых API: это обратная сторона предыдущего преимущества. Дизайнерам и разработчикам не нужно изобретать велосипед каждый раз, когда они создают API, основанный на коллекциях; вместо этого они могут использовать стандартные интерфейсы коллекций.  
е) Способствует повторному использованию программного обеспечения: новые структуры данных, соответствующие стандартным интерфейсам коллекций, по своей природе допускают повторное использование. То же самое касается новых алгоритмов, работающих с объектами, реализующими эти интерфейсы.  
**Источник.**  https://docs.oracle.com/javase/tutorial/collections/intro/index.html

7: Является ли антипаттерном следующее объявление ссылки на коллекцию?  
```Collection collection;```
Если да, то как называется антипаттерн и исправьте объявление ссылки.  
**Ответ.** Данное объявление является антипаттерном - `raw type`. Правильное объявление будет выглядеть следующим образом:  
`Collection<...> collection`.  

8: К каким негативным последствиям может привести использование `raw types`?  
Приведите пример.  
**Ответ.**  
Когда вы объявляете `Collection` экземпляр, вы можете и должны указать тип объекта,
содержащегося в коллекции. Указание типа позволяет компилятору проверить (во время компиляции),
что тип объекта, который вы помещаете в коллекцию, является правильным, тем самым уменьшая количество
ошибок во время выполнения.

```java 
public class UncheckCheckRun {
public static void main(String[ ] args) {
 ArrayList raw = new ArrayList() { // "сырая" коллекция – raw type
 { // логический блок анонимного класса
 add(new Order(231, 12.f));
 add(new Item(23154, 120.f, "Xerox"));
 add(new Order(217, 1.7f));
 }
 };
 // при извлечении требуется приведение типов
 Order or1 = (Order) raw.get(0);
 Item or2 = (Item) raw.get(1);
 Order or3 = (Order) raw.get(2);
 for (Object ob : raw) {
 System.out.println("raw " + ob);
 }
 ArrayList<Order> orders = new ArrayList<Order>() {
 {
 add(new Order(231, 12.f));
 add(new Order(389, 2.9f));
 add(new Order(217, 1.7f));
 // add(new Item(23154, 120.f, "Xerox"));
				// ошибка компиляции: список параметризован
 }
 };
 for (Order ob : orders) {
 System.out.println("Order: " + ob);
 } 
 } 
 }
```
**Источник.** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 256  
https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html


9: Почему допускаются `raw types` с коллекциями?  
**Ответ.** Необработанные типы (`raw types`) отображаются в устаревшем коде, потому что многие классы `API`
(например, классы `Collections`) не были универсальными до `JDK 5.0`.
При использовании необработанных типов вы, по сути, получаете поведение до дженериков.  
Есть всего три случая, когда использовать обобщенный тип без параметра правильно:  
• Целевая версия `Java < 5.0 `(2002 год и ранее – вряд ли это ваш случай);  
• В литерале класса. `List<String>.class` не сработает, нужно писать `List.class`;  
• В операторе `instanceof`. Вместо `instanceof Set<Integer>` должно быть `instanceof Set`.  
**Источник:** https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html  
https://itsobes.ru/JavaSobes/kogda-nuzhno-ispolzovat-raw-types/  

10: Какое главное назначение раздела Интерфейсы?  
Другими словами, если известен интерфейс коллекции, то что это дает программисту?  
**Ответ.** Если известен интерфейс коллекции, то программист понимает множество методов,
которые каждый класс, использующий интерфейс, должен реализовывать. Так же очевидна основной функционал созданной коллекци.
На примере интерфейса `List` программисту очевидно что коллекция будет представлять собой список (не множество, не карту и т.д.)
Соответственно классы для реализации - `ArrayList, LinkedList и др.`.   
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  

11: Какое главное назначение раздела Имплементации?  
Другими словами, если известна имплементация, то что это дает программисту?  
**Ответ.**  Увеличивает скорость и качество программы: По сути, это повторно используемые структуры данных. Различные реализации каждого
интерфейса взаимозаменяемы, поэтому программы можно легко настраивать, переключая реализации коллекций.
Поскольку вы освобождаетесь от рутинной работы по написанию собственных структур данных,
у вас появляется больше времени для улучшения качества и производительности программ.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  

12: Приведите иерархию интерфейсов коллекций.  
**Ответ.** От интерфейса `Collection` - по иерархии идут интерфейсы - `List, Set, Queue, Deque` от
интерфейса `Set` - `SortedSet`;
Отдельная иерархия не принадлежащая `Collection` иерархия интерфейса `Map` - `SortedMap`;  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html

13: Какие существуют способы прохода (`traversing`) по коллекции до версии java 8 (т.е. от версии 5 до версии 7 включительно)?  
Приведите идиомы для следующей коллекции:  
`Collection<Entity> entities = …;`
Какой способ является более подходящим для прохода по коллекции до версии java 8?  
**Ответ.** `for-each` конструкция позволяет вам сжато перемещаться по коллекции или массиву с помощью `for`
цикла — см . Оператор `for`. Следующий код использует `for-each` конструкцию для вывода каждого элемента
коллекции в отдельной строке.  
`Iterator` — это объект, который позволяет вам перемещаться по коллекции и выборочно удалять
элементы из коллекции, если это необходимо. Вы получаете `Iterator` коллекцию, вызывая ее `iterator` метод.
```java 
Collection<Enity> entities = ...;
for (Enity e : entities) {
System.out.println(e);
}
 for (Iterator<Entity> it = entities.iterator(); it.hasNext(); )
        if (!cond(it.next()))
            it.remove();
```  
В зависимости от условия поставленной задачи следует выбирать определенный способ прохода. Если по условию
кроме вывода требуется проводить операции удаление текущего элемента следует использовать `Iterator`.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html


14: Реализация какого интерфейса позволяет коллекциям использоваться в конструкции `for-each`?  
Какой метод этого интерфейса обеспечивает данную возможность?  
**Ответ.** Интерфейс `Collection` расширяет интерфейс `Iterable`. Поэтому цикл "for each" можно
использовать для любого набора данных из стандартной библиотеки.
Компилятор преобразует цикл `for each` в обычный цикл с итератором. Цикл `for each` работает с
любым объектом, реализующим интерфейс `Iterable`, в котором объявлен единственный метод
```java 
public interface Iterable <E>
{
    Iterator <E> iterator();
}
```
**Источник.** https://java-online.ru/java-collection.xhtml  

15: Что такое итератор?  
**Ответ.** Интерфейс `Iterator<E>` используется для построения объекта, который
обеспечивает доступ к элементам коллекции. К этому типу относится объект,
возвращаемый методом `iterator()`. Такой объект позволяет просматривать содержимое коллекции
последовательно, элемент за элементом. Позиции итератора располагаются в коллекции между элементами.  
**Источник.** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 255

16: Дана коллекция из `n` элементов.  
Сколько в ней существует возможных позиций курсора итератора?  
**Ответ.** В коллекции, состоящей из `n` элементов, существует `n+1` позиций итератора. В коллекции без элементов `n = 0` существует 1 позиция курсора.    
**Источник.** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 255  

17: Какие методы объявлены в интерфейсе `Iterator<E>`?  
Охарактеризуйте их.  
**Ответ.**  
Методы интерфейса `Iterator<E>`:
```java 
boolean hasNext() — проверяет наличие следующего элемента, а в случае 
его отсутствия (завершения коллекции) возвращает false. Итератор при этом 
остается неизменным;
E next() — возвращает ссылку на объект, на который указывает итера-
тор, и передвигает текущий указатель на следующий, предоставляя доступ 
к следующему элементу. Если следующий элемент коллекции отсутствует, 
то метод next() генерирует исключение NoSuchElementException;
void remove() — удаляет объект, возвращенный последним вызовом метода 
next(). Если метод next() до вызова remove() не вызывался, то будет сгенериро-
вано исключение IllegalStateException.
```  
**Источник.** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 255

18: В каких случаях следует явно использовать итератор вместо `for-each`?  
**Ответ.** Используйте `Iterator` вместо `for-each` конструкции, когда вам нужно:  
а) Удалить текущий элемент. Конструкция `for-each` скрывает итератор, поэтому вы не можете вызвать `remove`.
Поэтому эту `for-each` конструкцию нельзя использовать для фильтрации.  
б) Параллельно перебирать несколько коллекций.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html  


19: Пусть условие удаления элемента из коллекции `Collection<Entity> entities` задается методом `isRemoved()` класса `Entity`.  
Приведите идиому удаления элементов этой коллекции.  
**Ответ.**  
```java 
    for (Iterator<Entity> iter = entities.iterator(); it.hasNext();) 
        if (!iter.next().isRemoved()) 
            iter.remove(); 
``` 

20: Какие группы методов (или операций) объявлены в интерфейсе `Collection`
(до java 8)?  
Какие методы входят в каждую группу?  
**Ответ.**  
Интерфейс `Collection` содержит методы, выполняющие основные операции, такие как:
`int size(),
boolean isEmpty(),
boolean contains(Object element),
boolean add(E element),
boolean remove(Object element) и
Iterator<E> iterator().`  
Он также содержит методы, работающие с целыми коллекциями, такие как:
`boolean containsAll(Collection<?> c), 
boolean addAll(Collection<? extends E> c), 
boolean removeAll(Collection<?> c),
boolean retainAll(Collection<?> c) и
void clear().`
Дополнительные методы для операций с массивами такие как:
`Object[] toArray() и <T> T[] toArray(T[] a)`.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

21: В чем разница методов `Object[] toArray()`, `<T> T[] toArray(T[]` a) интерфейса `Collection`?  
**Ответ.** 
```java
Object[] toArray() — копирует элементы коллекции в массив объектов;
<T> T[] toArray(T a[]) — копирует элементы коллекции в массив объектов
определенного типа.
``` 
Метод `<T> T[] toArray(T a[])` отличается тем, что копирует элементы определенного типа, в то время как 
метод `Object[] toArray()` копирует объекты типа `Object` то есть любого типа.  
**Источник.** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 255  

22: В описании методов интерфейсов коллекций в `JavaDoc` есть методы, помеченные фразой “`optional operation`”.  
**Ответ.**
```Modifier and Type
Method and Description
boolean
add(E e)
Ensures that this collection contains the specified element (optional operation).
boolean
addAll(Collection<? extends E> c)
Adds all of the elements in the specified collection to this collection (optional operation).
void
clear()
Removes all of the elements from this collection (optional operation).
```
Как это понимать?  
**Ответ.** Необязательными методами в `JavaDoc` называются методы интерфейса которые не обязан реализовывать
класс, реализующий интерфейс. Вместо этого вместо этого они могли бы, например, создать исключение.
Эти методы могут, но не обязаны, выдавать `UnsupportedOperationException` если вызов не повлияет на коллекцию.  
**Источник.** https://stackoverflow.com/questions/8375653/what-does-optional-operation-mean-in-javadoc-of-for-example-setadde

23: Какую математическую сущность моделирует интерфейс `Set`?  
**Ответ.** Интерфейс `Set` моделирует математическую абстракцию множества.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

24: Какое основное свойство всех имплементаций интерфейса `Set`, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Интерфейс `Set`имеет 3 имплементации, которые не могут содержать повторяющиеся элементы.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

25: Может ли множество содержать `null` элемент?  
**Ответ.** Множество может содержать `null` элемент, но в случае `TreeSet` только если `null`
элемент один, т.к. при наличии других элементов происходит `compareTo` что приводит к `NPE`. `EnumSet` не может содержать `null` элементы.   
**Источник.** https://habr.com/ru/post/164027/

26: Есть ли отношение следования (предыдущий, текущий, следующий элемент) в множестве?  
Если нет, то есть ли у множества итератор?  
**Ответ.** Отношение следования в множестве нет, однако интерфейс `Set` имеет итератор.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

27: Как получить элемент множества по индексу?  
**Ответ.** Отношение следования в множестве нет, однако интерфейс `Set` имеет итератор.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

28: Как реализован метод `add()` во множестве?  
**Ответ.** Метод `add` добавляет указанный элемент в, `Set` если он еще не присутствует, и возвращает логическое
значение, указывающее, был ли добавлен элемент.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

29: Какая группа методов увеличилась в интерфейсе `Set` по сравнению с интерфейсом `Collection`?  
Какие методы добавились?  
**Ответ.** Интерфейс `Set` содержит только методы, унаследованные от `Collection`.
Так же у `Set` есть перегруженные методы `containsAll, addAll, retainAll, removeAll`,
которые принимают `Set`, как аргумент и соответствуют математическим операциям над множествами.  
**Источник.** https://metanit.com/java/tutorial/5.4.php  

30: Зависит ли множество, как структура данных, от имплементации?  
Обоснуйте ответ.  
**Ответ.**  Да, т.к. переменные и параметры множества должны соответствовать типу реализации.
Обратите внимание, что код всегда ссылается на `Collection` тип интерфейса `Set`,
а не на тип реализации. Это настоятельно рекомендуемая практика программирования, поскольку она
дает вам возможность изменять реализации, просто изменяя конструктор.
Если какая-либо из переменных, используемых для хранения коллекции, или параметры,
используемые для ее передачи, объявлены как имеющие `Collection` тип реализации,
а не тип его интерфейса, все такие переменные и параметры должны быть изменены, чтобы изменить его тип реализации.
Кроме того, нет никакой гарантии, что получившаяся программа будет работать.
Если в программе используются какие-либо нестандартные операции, присутствующие в исходном
типе реализации, но отсутствующие в новом, программа завершится ошибкой. Обращение к коллекциям
только по их интерфейсу предотвращает использование каких-либо нестандартных операций.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

31: Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу `HashSet` имплементации?  
**Ответ.** `Set` также добавляет более строгое соглашение о поведении операций `equals` и `hashCode`,
что позволяет `Set` осмысленно сравнивать экземпляры, даже если их типы реализации различаются.
Два `Set` экземпляра равны, если они содержат одни и те же элементы.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

32: Какие соглашения установлены для переопределения метода `hashCode()`?  
**Ответ.** Хэш — это некоторое число, генерируемое на основе объекта и описывающее его состояние в какой-то
момент времени. Это число используется в Java преимущественно в хэш-таблицах, таких как `HashMap`.
При этом хэш-функция получения числа на основе объекта должна быть реализована таким образом, чтобы
обеспечить относительно равномерное распределение элементов по хэш-таблице. А также минимизировать
вероятность появления коллизий, когда по разным ключам функция вернет одинаковое значение.  
Для реализации хэш-функции в спецификации языка определены следующие правила:  
а) Вызов метода `hashCode` один и более раз над одним и тем же объектом должен возвращать одно и
то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
б) Вызов метода `hashCode` над двумя объектами должен всегда возвращать одно и то же число, если
эти объекты равны (вызов метода `equals` для этих объектов возвращает `true`).
в) Вызов метода `hashCode` над двумя неравными между собой объектами должен возвращать
разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его
выполнение положительно повлияет на производительность работы хэш-таблиц.
**Источник.** https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam

33: Почему недостаточно переопределить один только метод `hashCode()`?  
**Ответ.**  Исходя из описанных выше контрактов следует, что переопределяя в своем коде метод `equals`,
необходимо всегда переопределять и метод `hashCode`. Так как фактически два экземпляра класса
отличаются, потому что находятся в разных областях памяти, сравнивать их приходится по некоторым
логическим признакам. Соответственно, два логически эквивалентных объекта, должны возвращать
одинаковое значение хэш-функции.  
**Источник.** https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam

34: Являются ли приведенная реализация `hashCode()` допустимой (в смысле будут ли правильно выполняться все операции над множеством)?  
```java
@Override
public int hashCode() {
return 22;
}
```
**Ответ.** Такая реализация допустима, однако такая реализация не предполагает достаточную уникальность для сравнения.
Каждый объект класса будет иметь одинаковый хэш код, вне зависимости от значений полей класса.
Так же данная реализация повлияет поиск и получение (удаление) элементов множества, т.к. эти операции проходят при помощи
`hashCode` который в данном случае будет одинаковый у всех объектов.

35: Являются ли приведенная реализация `hashCode()` допустимой (в смысле будут ли правильно выполняться все операции над множеством `HashSet<Entity>)`?  
```java
class Entity {
private int value;
public int getValue() {
return value;
}
public void setValue(int value) {
this.value = value;
}
@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null || getClass() != obj.getClass()) return false;
Entity entity = (Entity) obj;
return value == entity.value;
}
@Override
public int hashCode() {
int result = 1;
result = result * 31 + value;
return result;
}
}
```
**Ответ.**  
Такая реализация не допустима. Т.к. предполагается что поле `value` может быть изменено с помощью сеттера, и так же поле
`value` участвует в генерации `hashCode` можно сделать вывод что после изменения `value` будет изменен и
`hashCode` элемента, соотвественно элемент попадет в другую "коризну". Таким образом может произойти "потеря элемента".  
**Источник.** https://habr.com/ru/post/162017/   

36: Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу `TreeSet` имплементации?  
**Ответ.** Метод `Comparator <? super E> comparator()` возвращает объект
`Comparator`, используемый для сортировки объектов множества или `null`,
если выполняется обычная сортировка. `TreeSet` экземпляр выполняет все сравнения элементов,
используя свой `compareTo(или compare)` метод, поэтому два элемента, которые считаются
равными этому метода с точки зрения множества равны.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html  
И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 273

37: В чем заключается актуальность внешнего компаратора?  
**Ответ.**
Преимущество использования `Comparator` (внешнего компаратора) заключается в том, что нет необходимости изменять
исходный код, а нужно реализовать компаратор. Когда нужно сравнить настраиваемый объект, компаратор
и объект могут быть переданы вместе для сравнения размера, а в `Comparator` Пользователи могут сами
реализовать сложную и универсальную логику.  
**Источник.** https://russianblogs.com/article/3860744737/  

38: Дана следующая коллекция:  
`Collection<Entity> entities = …;`
Приведите идиому, позволяющую оставить только уникальные элементы в коллекции при условии правильной реализации класса `Entity`.  
**Ответ.**  
```java 
Collection<Entity> entities = …;  //1 В случае если коллекция уже инициализированна без попомщи Set интерфейса
Set<Entity> entitiesSet = new HashSet<>(entities);
Collection<Entity> entities = new HashSet<>(entities); //2 В случае если коллекция по условию еще не была инициализирована 
```

39: Какую математическую сущность моделирует интерфейс `List`?  
**Ответ.**  
`List` — упорядоченная `Collection` (иногда называемая последовательностью).  
**Источник.**  https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html

40: Какое основное свойство всех имплементаций интерфейса `List`, т.е. что их объединяет независимо от имплементации?  
**Ответ.**  Обе имплементации интерфейса предполагают наличие упорядоченного "списка" к элементам которого можно обращаться
по индексу. Для быстрой работы с методами "вставки, удаления, получения" элементов.

41: Может ли имплементация интерфейса `List` содержать одинаковые элементы?  
Обоснуйте ответ.  
**Ответ.** Да. Списки могут содержать повторяющиеся элементы. Однако некоторые реализации интерфейса `List`
имеют некоторые ограничения. К примеру не могут содержать элементы `null`.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html  

42: Какие группы методов увеличились в интерфейсе `List` по сравнению с интерфейсом `Collection`?  
Какие методы добавились?  
**Ответ.**  
```java 
void add(int index, E element)— вставляет element в позицию, указанную в index; 
E remove(int index)— удаляет объект из позиции index; 
E set(int index, E element)— заменяет объект в позиции index, возвращает 
при этом удаляемый элемент;
void addAll(int index, Collection<? extends E> c)— вставляет в вызывающий 
список все элементы коллекции с, начиная с позиции index; 
E get(int index)— возвращает элемент в виде объекта из позиции index;
int indexOf(Object ob)— возвращает индекс указанного объекта;
List<E> subList(int fromIndex, int toIndex) — извлекает часть коллекции 
в указанных границах.
```
**Источник.** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 256  

43: Влияют ли изменения внесенные в последовательность, возвращаемый методом `subList()`, на исходную последовательность?  
**Ответ.** Да, при использовании операции `subList` необходимо проявлять некоторую осторожность.
Семантика `List` возвращаемого `subList` становится неопределенной, если элементы добавляются
или удаляются из резервной копии `List` любым способом, кроме как через возвращаемый `List`.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html  

44: Дана следующая последовательность:  
`List<Entity> entities = …;`
Приведите идиому, позволяющую удалить все элементы с номерами из полусегмента `[fromIndex; toIndex)`.  
**Ответ.**  
**Ответ:**
```java 
List<Entity> entities = …;
entities.subList(fromIndex, toIndex).clear();
```  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html  

45: Дана следующая неупорядоченная последовательность и некоторый элемент для сравнения:  
`List<Entity> entities = …;`  
`Entity cmpEntity = …;`  
Приведите идиому для выполнения метода `void doAction()` класса `Entity` со всеми элементами последовательности `entities`, которые совпадают с элементом `cmpEntity`.  
Запрещается упорядочивать последовательность и явно проверять на равенство каждый элемент последовательности.  
**Ответ.**  
```java 
List<Entity> entities = …;
Entity cmpEntity = …;
int id = 0;
while(entities.indexOf >= 0) {
id = entities.indexOf(cmpEnity);
entities.get(id).doAction();
entities.remove(id);
}
```

46: Какую математическую сущность моделирует интерфейс `Queue`?  
**Ответ.** `Queue` – это очередь. Элементы добавляются в конец очереди, а выбираются из ее начала.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html  

47: Какое основное свойство всех имплементаций интерфейса `Queue`, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Каждая имплементация интерфейса `Queue` должна указывать свои свойства упорядочивания
элементов в очереди, при этом элементы добавляются в один конец списка, а извлекаются из другого конца.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html

48: Какие группы методов увеличились в интерфейсе `Queue` по сравнению с интерфейсом `Collection`?  
Какие методы добавились?  
**Ответ.**  
Помимо основных `Collection` операций, очереди предоставляют дополнительные операции вставки, удаления и проверки.
```java 
Методы интерфейса Queue:
boolean add(E o) вставляет элемент в очередь, но если же очередь полностью заполнена, то генерирует исключение IllegalStateException;
boolean offer(E o) вставляет элемент в очередь, если возможно;
E element() возвращает, но не удаляет головной элемент очереди;
E peek() возвращает, но не удаляет головной элемент очереди, возвращает null, если очередь пуста;
E poll() возвращает и удаляет головной элемент очереди, возвращает null, если очередь пуста;
E remove() возвращает и удаляет головной элемент очереди.
```  
**Источник.** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 268  
https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html

49: Какую математическую сущность моделирует интерфейс `Deque`?  
**Ответ.**  Отсутствует математическая сущность, которая моделируется.  
Двусторонняя очередь — это линейный набор элементов, который поддерживает вставку и удаление
элементов в обеих конечных точках.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html

50: Какое основное свойство всех имплементаций интерфейса `Deque`, т.е. что их объединяет независимо от имплементации?  
**Ответ.**  Интерфейс `Deque` представляет собой более богатый абстрактный тип данных, чем оба, `Stack`
и `Queue` потому, что он одновременно реализует и стеки, и очереди. Интерфейс `Deque` определяет методы
для доступа к элементам на обоих концах `Deque` экземпляра.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html  

51: Какие методы определяет `Deque` в добавок к методам унаследованным от `Queue`?  
**Ответ.**  
```java
Вставлять
Методы addfirst и offerFirst вставляют элементы в начало Deque экземпляра.
Методы addLast и offerLast элементы вставки в конце Deque экземпляра.
Когда емкость Deque экземпляра ограничена, предпочтительными методами являются offerFirst и
offerLast потому что addFirst может не вызвать исключение, если он заполнен.
Удалять
Методы removeFirst и pollFirst удаляют элементы из начала Deque экземпляра.
Методы removeLast и pollLast удаляют элементы с конца.
Методы pollFirst и pollLast возвращаются null, если Deque пусто, тогда как методы
removeFirst и removeLast выдают исключение, если Deque экземпляр пуст.
Забрать
Методы getFirst и peekFirst получить первый элемент Deque экземпляра. Эти методы не удаляют значение из
Deque экземпляра. Точно так же методы getLast и peekLast извлекают последний элемент. Методы getFirst
и getLast выдают исключение, если deque экземпляр пуст, тогда как методы peekFirst и peekLast возвращают NULL.
``` 
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html  

52: Верно ли утверждение, что Queue всегда обрабатывает элемента в порядке `FIFO`?  
**Ответ.**  Очереди обычно, но не обязательно, упорядочивают элементы в порядке FIFO
(первым поступил – первым обслужен). Исключениями являются приоритетные очереди, которые
упорядочивают элементы в соответствии с их значениями.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html

53: Какой элемент независимо от упорядочения `Queue` будет удален методами `remove` и `poll`?  
**Ответ.** Независимо от используемого порядка, в начале очереди находится элемент,
который будет удален вызовом `remove` или `poll`. В очереди `FIFO` все новые элементы вставляются в
хвост очереди. В других видах очередей могут использоваться другие правила размещения.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html  

54: Зачем в интерфейсе `Queue` метод `poll`, когда есть `remove`?  
**Ответ.** Методы `remove` и `poll` удаляют и возвращают голову очереди. Какой именно элемент будет
удален, зависит от политики упорядочивания очереди. Методы `remove` и `poll` отличаются своим поведением
только тогда, когда очередь пуста. В этих условиях `remove` бросает `NoSuchElementException`,
а `poll` возвращает `null`.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html

55: Какую математическую сущность моделирует интерфейс `Map`?  
**Ответ.** Интерфейс `Map` моделирует абстракцию математической функции.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

56: Какое основное свойство всех имплементаций интерфейса `Map`, т.е. что их объединяет независимо от имплементации?  
**Ответ.**  `Map` — это объект, который сопоставляет ключи значениям. Карта не может содержать
повторяющиеся ключи: каждый ключ может соответствовать не более чем одному значению.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

57: Реализует ли `Map` интерфейс `Collection`?  
**Ответ.** В отличие от других интерфейсов, которые представляют коллекции,
интерфейс `Map` НЕ расширяет интерфейс `Collection`.  
**Источник.** https://metanit.com/java/tutorial/5.8.php  

58: Какую структуру данных представляет собой совокупность  
ключей;  
значений;  
пар ключ-значение  
любой имплементации `Map`?  
**Ответ.**  
а) Структура данных, представляющая совокупность ключей - `Set`  
метод для получения данной структуры - `keySet()` — возвращает множество(`Set`) ключей;    
б) Структура данных, представляющая совокупность значения - `Collection`  
метод для получения данной структуры - `values()` — возвращает коллекцию(`Collection`) значений;    
в) Структура данных, представляющая совокупность пар ключ-значение - `Set`  
метод для получения данной структуры - `entrySet()` — возвращает множество(Set) наборов “ключ-значение”.    
**Источник.** https://javarush.ru/groups/posts/2542-otvetih-na-samihe-populjarnihe-voprosih-ob-interfeyse-map  

59: Какие группы операций определены в интерфейсе `Map`?  
**Ответ.**  
а) Основные операции  
`Map` (put, get, containsKey, containsValue, size и isEmpty) ведут себя точно
так же, как их аналоги в `Hashtable`.  
б) Массовые операции интерфейса карты  
Операция `clear` удаляет все сопоставления из файла Map.
Операция `putAll` является `Map` аналогом работы `Collection` интерфейса `addAll`.  
в) Представления коллекции  
Методы представления коллекции позволяют рассматривать карту как коллекцию тремя способами:  
-`keySet` - набор ключей, содержащихся в карте.  
-`values` - Коллекция значений, содержащихся в карте. Эта коллекция не является набором, поскольку
несколько ключей могут сопоставлять одно и то же значение.  
-`entrySet` - набор пар ключ-значение, содержащихся в карте. Интерфейс `Map` предоставляет небольшой
вложенный интерфейс `Map.Entry`, тип элементов этого набора.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html

60: Какой интерфейс представляет мультикарту (`multimap`) в `Collections Framework`?  
**Ответ.** `Java Collections Framework` не включает интерфейс для мультикарт, потому что они не так
часто используются. Довольно просто использовать Map, значения которого являются `List`
экземплярами, в качестве мультикарты.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

61: Дана карта:
```Map<K, V> map = …;```
Приведите идиому для выполнения метода `void doAction(K key, V value)` со всеми элементами карты.  
**Ответ.**  
```java 
public class Runner {
    public static void main(String[] args) {
        Map<K,V> mapForAction = ...;
        mapForAction.put(...);
        mapForAction.put(...);
        mapForAction.put(...);
        for (Map.Entry<K,V> entry : mapForAction.entrySet()){
            doAction(entry.getKey(), entry.getValue());
        }
    }
    private static void doAction(K key, V value){
        System.out.println("Do something whit key and value: " + key + " => " + value);
    }
}
```

62: Дана карта:
`Map<K, V> map = …;`
в которой нет элементов со значением `null`.
Приведите идиому для выполнения метода `void doAction(V value)` с элементом `map`, заданным ключом `K key`.  
**Ответ.**  
```java
public class Main {
    public static void main(String[] args) {
          Map<K,V> mapForAction = ...;
        mapForAction.put(...);
        mapForAction.put(...);
        mapForAction.put(...);
        
        V value = map.get(key);
        if(value != null) {
         doAction(value); 
        }
    private static void doAction(int value) {
        System.out.println("Do something whit key and value: " + value);
    }
}
```

63: Дана карта:
`Map<K, V> map = …;`
в которой есть элементы со значением `null`.
Приведите идиому для выполнения метода `void doAction(V value)` с элементом `map`, заданным ключом `K key`.  
**Ответ.**  
```java 
public class Main {
    public static void main(String[] args) {
          Map<K,V> mapForAction = ...;
        mapForAction.put(...);
        mapForAction.put(...);
        mapForAction.put(...);
        K key = ...;
        if(map.containsKey(key)) {
        doAction(map.get(key)); 
        }
    }
    private static void doAction(int value) {
        System.out.println("Do something whit key and value: " + value);
    }
}
```

64: Можно ли отрефакторить следующий код?  
Если да, то сделайте это.  
```java
Purchase purchase = new Purchase("meat", new Byn(100), 10);
for (Map.Entry<Purchase, WeekDay> entry: purchaseWeekDayMap.entrySet()) {
if (entry.getKey().equals(purchase)) {
System.out.println(entry.getKey());
break;
}
}
```
**Ответ.**  
```java 
Purchase purchase = new Purchase("meat", new Byn(100), 10);
WeekDay weekDay = purchaseWeekDayMap.get(purchase);
if (weekDay != null) {
System.out.println(weekDay);
}
``` 
Изначально использовался линейный поиск по `Map` с вычислительной сложностью `O(n)`.  
В ответе он был заменен на поиск элемента в `Map` по хеш-функции - сложность `O(1)`.  

65: Что возвращает метод `put` интерфейса `Map`?  
**Ответ.**  `V put(K key, V value)`— помещает ключ `key` и значение `value` в вызывающую
карту. При добавлении в карту элемента с существующим ключом произойдет
замена текущего элемента новым. При этом метод возвратит заменяемый элемент;  
**Источник.** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 276

66: Почему интерфейс `Map` не расширяет интерфейс `Collection` в `Java Collections Framework`?  
**Ответ.**  
`Map` - это совокупность пар "ключ"-"значение".
Соответственно некоторые методы интерфейса `Collection` нельзя использовать в `Map`.
Например, метод `remove(Object o)` в интерфейсе `Collection` предназначен для удаления элемента,
тогда как такой же метод `remove(Object key)` в интерфейсе `Map` - удаляет элемент по заданному ключу.  
**Источник.** https://parshinpn.ru/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-1

67: Дайте определение понятию имплементация (`Implementation`) в контексте `Collections Framework`.  
**Ответ.** Имплементация — это объекты данных, используемые для хранения коллекций, которые реализуют интерфейсы.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/summary.html  

68: Какие виды имплементаций можно выделить?  
**Ответ.**  
а) Реализации общего назначения — это наиболее часто используемые реализации, предназначенные для
повседневного использования.  
б) Реализации специального назначения - предназначены для использования в особых ситуациях и
демонстрируют нестандартные характеристики производительности, ограничения использования или поведение.  
в) Параллельные реализации - предназначены для поддержки высокого параллелизма, как правило, за счет
однопоточной производительности.  
д) Реализации-оболочки - используются в сочетании с другими типами реализаций, часто универсальными,
для предоставления дополнительных или ограниченных функций.  
е) Удобные реализации — это мини-реализации, обычно доступные через статические фабричные методы,
которые предоставляют удобные и эффективные альтернативы универсальным реализациям для
специальных коллекций (например, одноэлементных наборов).  
ж) Абстрактные реализации — это скелетные реализации, которые упрощают создание пользовательских
реализаций, описанных ниже в разделе « Реализации пользовательских коллекций ».  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/index.html  

69: На что влияет выбор имплементации?  
**Ответ.** От выбора имплементации напрямую зависят ресурсоемкость, скорость выполнения и производительность.  

70: Идиома создания пустой коллекции имеет следующий вид:  
`SomeInterface<Entity> entities = new SuitableImplementation<>();`  
Почему в левой части идиомы используется ссылка на интерфейс, а не на имплементацию?  
**Ответ.** Это настоятельно рекомендуемая практика программирования, поскольку она дает вам
возможность изменять реализации, просто изменяя конструктор. Если какая-либо из переменных,
используемых для хранения коллекции, или параметры, используемые для ее передачи, объявлены
как имеющие `SomeInterface` тип реализации, а не тип его интерфейса, все такие переменные и параметры
должны быть изменены, чтобы изменить его тип реализации.   
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

71: Укажите наиболее часто используемые имплементации для интерфейсов Collections Framework, а также структуру данных, которая поддерживается данной имплементацией.
Результат представьте в виде таблицы:
Interface	Implementation	Abstract Data Type
-----------------------------------------------------------------------

72: Приведите идиому создания очереди.
Xxx<Integer> queue = ...;
Xxx - это подходящий интерфейс.
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.

73: Приведите идиому создания стека.
Xxx<Integer> stack = ...;
Xxx - это подходящий интерфейс.
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.


74: Когда целесообразно использовать реализацию TreeSet вместо HashSet?

75: Опишите неупорядоченные реализации Map.

76: Опишите упорядоченные реализации Map.

77: Чем отличается ArrayList и LinkedList?

78: Что такое вычислительная сложность операции (алгоритма)?

79: Укажите вычислительную сложность для операций получения элемента по индексу, поиска, вставки и удаления, для основных коллекций.

80: В чем разница между интерфейсами Comparable и Comparator?

81: В чем разница между Iterator и ListIterator?

82: Почему в классе Iterator нет метода для получения следующего элемента без передвижения курсора?

83: Назовите высокопроизводительные реализации Set для перечислимых типов (enum)?

84: Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?

85: Можно ли использовать массив в качестве ключа для HashMap?
Если да, то какие есть особенности.

86: Где определены полиморфные алгоритмы для работы с коллекциями? Опишите основные группы.

87: В чем заключается назначение метода
Collections.unmodifiableCollection(Collection<? extends T> c)?


88: Перечислите различия между массивами и коллекциями?

89: Массивы и коллекции являются ковариантными или инвариантными?
Поясните ответ.

90: Дано:
SortedSet<Entity> set = ...;
Найдите в jdk
тип 1, для которого SortedSet<Entity> является подтипом.
подтип 2 для SortedSet<Entity>.
Создайте множество set1 типа 1 и множество set2 подтипа 2. Проверьте правильность, сделав присваивания:
set1 = set;
set = set2;


91: Массивы и коллекции являются reified (овеществленные) или non-reified типами?
Поясните ответ. 
