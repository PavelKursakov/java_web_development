1: Что такое исключения?  
**Ответ.** Термин `«исключение»` является сокращением от фразы `«исключительное событие»`.Исключение — это событие, возникающее во время выполнения программы и нарушающее нормальный ход инструкций программы.Когда в методе возникает ошибка, метод создает объект и передает его системе времени выполнения. Объект, называемый объектом исключения , содержит информацию об ошибке, в том числе ее тип и состояние программы в момент возникновения ошибки. Создание объекта исключения и передача его системе выполнения называется созданием исключения.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html    

2: Какие действия производит система времени выполнения при возникновении исключения?  
**Ответ.** Система выполнения ищет в стеке вызовов метод, содержащий блок кода, способный обработать исключение. Этот блок кода называется обработчиком исключений`(exception handler)` . Поиск начинается с метода, в котором возникла ошибка, и продолжается по стеку вызовов в порядке, обратном тому, в котором были вызваны методы. Когда соответствующий обработчик найден, система выполнения передает исключение обработчику. Обработчик исключения считается подходящим, если тип создаваемого объекта исключения соответствует типу, который может быть обработан обработчиком.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html

3: Как называется блок кода, который обрабатывает исключение?  
**Ответ.** Обработчик исключений `(exception handler)`.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html  

4: Как реализуется требование «Поймай или Укажи» `(Catch or Specify)`?  
**Ответ.**  Действительный код языка программирования `Java` должен соответствовать требованию `Catch or Specify Requirement`. Это означает, что код, который может генерировать определенные исключения, должен быть заключен в один из следующих элементов:  
а) Оператор `try`, который перехватывает исключение. Должен предоставлять обработчик для исключения, как описано в разделе Перехват и обработка исключений.  
б) Метод, указывающий, что он может генерировать исключение. Метод должен предоставлять `throws` предложение, в котором перечислены исключения, как описано в разделе «Указание исключений, создаваемых методом».  
Код, который не соответствует требованию `Catch` или `Specify`, не будет компилироваться.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/catchOrDeclare.html  

5: Какая иерархия классов исключений?  
**Ответ.**  Базовым классом для всех исключений является класс `Throwable`. От него уже наследуются два класса: `Error` и `Exception`. Все остальные классы являются производными от этих двух классов.
Класс `Error` описывает внутренние ошибки в исполняющей среде `Java`.  
**Источник.**  https://metanit.com/java/tutorial/4.2.php  

6: Какие виды исключений относятся к непроверяемым?  
**Ответ.**  
Ошибки и исключения во время выполнения вместе называются непроверенными исключениями`(unchecked exceptions)`.
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/catchOrDeclare.html  

7: Какие компоненты могут входить в обработчик исключений?  
**Ответ.** Обработчик исключений может содержать три компонента – блоки `try`, `catch` и
`finally`.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html  

8: Для каких ситуаций используется оператор `try-with-resources`?  
**Ответ.** Оператор `try-with-resources` особенно подходит для ситуаций, в которых используются `Closeable` ресурсы, такие как потоки.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html  

9: Какой код заключается в блок `try`?  
**Ответ.** Первым шагом в создании обработчика исключений является включение в `try` блок кода, который может вызвать исключение.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/try.html  

10: Выполняется ли весь код блока `try` в случае возникновения исключения?  
**Ответ.**  Сначала выполняется код внутри блока ```try {...}```.  
Если в нём нет ошибок, то блок ```catch(err)``` игнорируется: выполнение доходит до конца ```try``` и потом далее, полностью пропуская ```catch```.  
Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало ```catch(err)```. Переменная ```err``` (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.  

11: Может ли использоваться только один блок `try` (без `catch` или `finally`)?  
**Ответ.**  Нет! Отдельно блок `try` не используется.  

12: Какое назначение блока `catch`?  
**Ответ.**  Каждый `catch` блок является обработчиком исключения, который обрабатывает тип исключения, указанный его аргументом.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html  

13: Сколько блоков `catch` может содержаться после `try`-оператора?  
**Ответ.**  Можно связать обработчики исключений с `try` блоком, предоставляя один или несколько `catch` блоков непосредственно после `try` блока.   
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html  

14: Если применяется несколько блоков `catch`, то в каком порядке в случае возникновения исключения они вызываются?  
**Ответ.**  Подклассы исключений в блоках `catch` должны следовать перед любым
из их суперклассов, иначе суперкласс будет перехватывать эти исключения.
Блоки `catch` исполняются в том порядке, в котором они указаны. Однако выполняется только `catch`, соответствующий исключению.  
Например:
```java 
try { /* код, который может вызвать исключение */
} catch(IllegalArgumentException e) {
} catch(PatternSyntaxException e) { } /* никогда не может быть вызван: ошибка компиляции */
```
где класс ```PatternSyntaxException``` представляет собой подкласс класса
```IllegalArgumentException```.  
**Источник.** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 206-207

15: Какой код может быть между блоками `try` и `catch`?  
**Ответ.**  Никакой код не может находиться между концом `try` блока и началом первого `catch` блока.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html

16: Может ли использоваться блок `catch` без блока `try`?  
**Ответ.**  Невозможно иметь блок ```catch``` без ```try```. Блок ```try``` передает ошибку блоку ```catch```
соответственно если блок ```try``` отсутствует то блоку ```catch``` исключение передано не будет, в таком случае его наличие бессмысленно.  

17: Сколько типов исключений может обрабатывать один блок `catch`?  
**Ответ.**  В `Java SE 7` и более поздних версиях один `catch` блок может обрабатывать несколько типов исключений. Эта функция может уменьшить дублирование кода и уменьшить искушение перехватить слишком широкое исключение.
В `catch` предложении укажите типы исключений, которые блок может обрабатывать, и разделите каждый тип исключения вертикальной чертой (|):  
```java
catch (IOException|SQLException ex) {
    logger.log(ex);
    бросить экс;
}
```  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html

18: В случае отсутствия исключения в блоке `try` выполняется ли блок `catch`?  
**Ответ.** Нет, т.к. блок ```try``` передает исключение в блок ```catch``` соответственно при остутсвии исключения блок ```catch``` не будет запущен.  

19: Для чего используется блок `finally`?  
**Ответ.**  Блок `finally` — ключевой инструмент для предотвращения утечек ресурсов. При закрытии файла или ином восстановлении ресурсов поместите код в `finally` блок, чтобы гарантировать, что ресурс всегда будет восстановлен. Блок `finally` выполняется, когда `finally` блок выходит. Это гарантирует, что блок будет выполнен, даже если произойдет непредвиденное исключение. Система выполнения всегда выполняет операторы внутри `finally` блока независимо от того, что происходит внутри `try` блока. Так что это идеальное место для уборки.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html  

20: В случае отсутствия исключения в блоке `try` выполняется ли блок `finally` (при его наличии)?  
**Ответ.**  Может. Блок `finally` выполняется в любом случае.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/putItTogether.html  

21: Могут ли использоваться блоки `try-finally` без блока `catch`?  
**Ответ.**  Да. Ключевое слово ``finally`` создаёт блок кода, который будет выполнен после завершения блока
``try/catch``, но перед кодом, следующим за ним. Блок будет выполнен, независимо от того,
передано исключение или нет. Оператор ``finally`` не обязателен, однако каждый оператор ``try`` требует
наличия либо ``catch``, либо ``finally``.  
**Источник.** http://developer.alexanderklimov.ru/android/java/exception.php  

22: Приведите пример кода, в котором используется оператор `try-with-resources`.  
**Ответ.**  
В следующем примере считывается первая строка из файла. Он использует экземпляр `BufferedReader` для
чтения данных из файла. ``BufferedReader``- это ресурс, который необходимо закрыть после того,
как программа завершит работу с ним:
```java 
static String readFirstLineFromFile (String path) выдает исключение IOException {
     try (BufferedReader br =
                   new BufferedReader (новый FileReader (путь))) {
        вернуть br.readLine ();
    }
}
```
В этом примере ресурс, объявленный в `try` операторе `-with-resources`, является файлом `BufferedReader`.
Оператор объявления появляется в круглых скобках сразу после `try` ключевого слова.
Поскольку `BufferedReader` экземпляр объявлен в операторе `try-with-resource`, он будет закрыт независимо от того,
`try` завершается ли оператор нормально или внезапно (в результате того, что метод `BufferedReader.readLine` выбрасывает `IOException`).  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html

23: Какой оператор может использоваться вместо `try-with-resources`?  
**Ответ.**  До `Java SE 7` можно было использовать `finally` блок, чтобы гарантировать, что ресурс закрыт, независимо от того, `try` завершается ли оператор нормально или внезапно.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html

24: Может ли применяться оператор `try-with-resources` совместно с блоком `finally`?  
**Ответ.**  Оператор `try-with-resources` может иметь `catch и finally` блоки, как обычный `try` оператор.
В операторе `try-with-resources` любой блок `catch` or `finally` запускается после закрытия объявленных ресурсов.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html

25: Какое ключевое слово используется в сигнатуре метода, чтобы указать на возможность выбрасывания им исключения?  
**Ответ.**  Когда вы не планируете обрабатывать исключение в своем методе, но хотите предупредить
пользователей метода о возможных исключительных ситуациях — используйте ключевое слово `throws`. Это ключевое слово в сигнатуре метода означает, что при определенных условиях метод, может выбросить исключение  
**Источник.** https://javarush.ru/groups/posts/isklyucheniya-java

26: Сколько исключений может выбрасывать метод?  
**Ответ.**  Метод может выбрасывать любое кол-во исключений.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html  

27: Какое ключевое слово используется для гарантированного выбрасывания исключения?  
**Ответ.**  Независимо от того, что вызывает исключение, оно всегда генерируется вместе с `throw` оператором. Все методы используют `throw` оператор для создания исключения. Оператору `throw` требуется один аргумент: бросаемый объект. Выбрасываемые объекты являются экземплярами любого подкласса `Throwable` класса.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html

28: Можно ли создавать свои собственные классы исключений?  
**Ответ.**  Вы также можете создавать свои собственные классы исключений для представления проблем, которые могут возникнуть в написанных вами классах.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html  

29: Приведите примеры наиболее известных подклассов класса `Exception`.  
**Ответ.**  
```java
IOException - исключения ввода-вывода;
IllegalAccessException - запрещен доступ к классу;
ClassNotFoundException -  класс не найден;
RuntimeException - исключения, которые могут быть предотвращены программно;
NoSuchFieldException - запрашиваемое поле не существует;
NoSuchMethodException - запрашиваемый метод не существует;
```
**Источник.** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 203  

31: Приведите примеры наиболее известных подклассов класса `RuntimeException`.  
**Ответ.**  
```java 
ArithmeticException - Арифметическая ошибка: деление на ноль и др.  
ArrayIndexOutOfBoundsException - Индекс массива находится вне его границ  
ArrayStoreException - Назначение элементу массива несовместимого типа  
ClassCastException - Недопустимое приведение типов  
ConcurrentModificationException - Некорректный способ модификации коллекции  
IllegalArgumentException - При вызове метода использован некорректный аргумент  
IllegalMonitorStateException - Незаконная операция монитора на разблокированном   
объекте  
IllegalStateException - Среда или приложение находятся в некорректном   
состоянии  
IllegalThreadStateException - Требуемая операция не совместима с текущим   
состоянием потока  
IndexOutOfBoundsException - Некоторый тип индекса находится вне границ коллекции  
NegativeArraySizeException - Попытка создания массива с отрицательным размером  
NullPointerException - Недопустимое использование  ссылки  на null  
NumberFormatException - Невозможное преобразование строки в числовой формат  
StringIndexOutOfBoundsException - Попытка индексации вне границ строки  
MissingResourceException - Отсутствие файла ресурсов properties или имени   
ресурса в нем  
EnumConstantNotPresentException - Несуществующий элемент перечисления  
UnsupportedOperationException - Встретилась неподдерживаемая операция  
```
**Источник.** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 204  

32: Что такое сцепление исключений?  
**Ответ.** Приложение часто реагирует на исключение, вызывая другое исключение. По сути, первое исключение вызывает второе исключение. Очень полезно знать, когда одно исключение вызывает другое. Цепочки исключений помогают программисту сделать это.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html  

33: Приведите пример кода со сцеплением исключений.  
**Ответ.**  
```java
try {

} catch (IOException e) {
    throw new SampleException("Other IOException", e);
}
```
В этом примере при `IOException` перехвате создается новое `SampleException` исключение с присоединенной исходной причиной, и цепочка исключений передается обработчику исключений следующего более высокого уровня.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html  

34: Какая информация приводится при трассировке стека во время исключения?  
**Ответ.** Трассировка стека предоставляет информацию об истории выполнения текущего потока и перечисляет имена классов и методов, которые были вызваны в момент возникновения исключения. Трассировка стека — это полезный инструмент отладки, которым вы обычно пользуетесь при возникновении исключения.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html  

35: В каких случаях целесообразно создавать собственный класс исключения?  
**Ответ.**  Столкнувшись с выбором типа исключения, которое нужно выдать, вы можете либо использовать его, написанный кем-то другим — платформа `Java` предоставляет множество классов исключений, которые вы можете использовать, — либо вы можете написать свой собственный. Вам следует написать свои собственные классы исключений, если вы ответите утвердительно на любой из следующих вопросов:  
Вам нужен тип исключения, который не представлен на платформе `Java`?  
Помогло бы пользователям, если бы они могли отличить ваши исключения от исключений, создаваемых классами, написанными другими поставщиками?  
Выдает ли ваш код более одного связанного исключения?  
Если вы используете чужие исключения, будут ли пользователи иметь доступ к этим исключениям? Аналогичный вопрос: должен ли ваш пакет быть независимым и автономным?  
В противном случае вы, вероятно, можете использовать чужой.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/creating.html

36: Какой класс исключений может использоваться в качестве суперкласса для собственного исключения?  
**Ответ.**  Любой `Exception` подкласс может быть использован в качестве родительского класса для `LinkedListException`. Однако беглый взгляд на эти подклассы показывает, что они неуместны, поскольку либо слишком специализированы, либо совершенно не связаны с `LinkedListException`. Следовательно, родительский класс `LinkedListException` должен быть `Exception`.  
**Источник.**  https://docs.oracle.com/javase/tutorial/essential/exceptions/creating.html  

37: Какие исключения целесообразно делать проверяемыми, а какие – непроверяемыми?  
**Ответ.**  Исключения-наследника от класса `Exception` целесообразно делать проверяемыми,
от `RuntimeException` - непроверяемыми.  
**Источник.** http://www.quizful.net/post/java-exceptions  

38: Какие преимущества в механизме выбрасывания и обработки исключений?  
**Ответ.**  
а) Отделение кода обработки ошибок от «обычного» кода.  
б) Распространение ошибок вверх по стеку вызовов.  
в) Группировка и дифференциация типов ошибок.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html

39: Можно ли выбрасывать исключения в конструкторах?  
**Ответ.** Можно. С помощью ключевого слова `throw`.  

40: Может ли произойти потеря исключения? Если да – приведите пример.  
**Ответ.**  
Блок ``finally`` может вызвать потерю исключений. Пример:
```java 
import java.io.IOException;
/**
 * ExceptionLossTest
 */
public class ExceptionLossTest{
    public static void main(String[] args){
        try {
            try {
                throw new Exception("a");
            } finally {
                if (true) {
                    throw new IOException("b");
                }
                System.err.println("c");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("d");
            System.err.println(ex.getMessage());
        }
    }
}
```  
После инициации первого исключения – `new Exception("a")` – будет выполнен блок `finally`, в котором будет брошено исключение new ```IOException("b")```. И именно это исключение будет поймано и обработано. Исходное же исключение теряется.  
**Источник.** http://www.skipy.ru/technics/exceptions.html

41: Обладают ли исключения свойством транзакционности?  
**Ответ.**  Cвойством транзакционности исключения не обладают – действия, произведенные в блоке `try` до возникновения исключения, не отменяются поcле его возникновения.  
**Источник.** http://www.skipy.ru/technics/exceptions.html#no_trans

42: Является ли данный код антипаттерном?  
    Обоснуйте ответ.  
```java
void methodCatchesSomeException() {
...
try {
...
} catch (SomeException ex) {
...
}
...
}
```
**Ответ.**  
Нет, блок `try` и `catch` объявлены в методе верно, исключение (при его наличии) будет перехвачено.  

43: Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java
void methodThrowsSomeCheckedException() {
...
throw new SomeCheckedException();
...
}
```
**Ответ.** Да, у данного метода отсутствует объявление исключения в секции `throws` и передача вызывающему методу.  


44: Является ли данный код верным? Укажите почему.  
```java
void methodThrowsSomeCheckedException() throws SomeCheckedException {
...
throw new SomeCheckedException();
...
}
```
**Ответ.**  Код является верным т.к., в теле метода прописана генерация исключения которое в секции `throws` передает исключение вызывающему методу.  

45: Приведите примеры кода с выбросом `RuntimeException` явным образом и в случае программной ошибки.  
**Ответ.**  
```java 
public class RuntimeChecker {   
// явным образом  
    void methodThrowsSomeRuntimeException() {  
        throw new ArrayIndexOutOfBoundsException;
    }  
// в случае программной ошибки  
    void methodWithSomeRuntimeException() {  
        String[] someArray = new String[5];  
        String elementsWithTenId = someArray[10]; // result - ArrayIndexOutOfBoundsException   
    }  
}
```

46: Можно ли отрефакторить данный код? Если да, то выполните.  
```java
void methodThrowsSomeRuntimeException() {
...
throw new SomeRuntimeException();
...
}
```
**Ответ.**  Можно добавить информацию об ошибке при генерации исключения `SomeRuntimeException()`.  

```java
/**
 @throws SomeRuntimeException
 */
void methodThrowsSomeRuntimeException() {
...
throw new SomeRuntimeException();
...
}
```

47: Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java
void methodThrowsSomeRuntimeException() throws SomeRuntimeException {
throw new SomeRuntimeException();
...
}
```
**Ответ.**  Да, данный код - антипаттерн. Для исключений-подклассов класса `RuntimeException` `(unchecked)`
используемых для отображения программных ошибок, при выполнении приложения в объявлении
метода секция throws может отсутствовать, так как играет только информационную роль.   
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 276 с. 

48: В какой версии `Java` появился оператор `try-with-resources`? Приведите пример кода с использованием указанного оператора.  
**Ответ.**  Оператор `try-with-resources` появился в `Java SE 7`.  
```java 
static String readFirstLineFromFile(String path) throws IOException {
    try (BufferedReader br =
                   new BufferedReader(new FileReader(path))) {
        return br.readLine();
    }
}
```
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  

49: Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java
void methodWithAutocloseableInstance() {
...
try(SomeResource res = new SomeResource(...)) {
...
}
...
}
```
**Ответ.**  Да. В данном коде отсутсвуют блоки `catch` и `finally`. Блок `try` обязательно должен иметь блок `catch` или `finally`.  

50: Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java
void methodWithAutocloseableInstance() {
...
try(SomeResource res = new SomeResource(...)) {
...
} catch (CorrectCheckedException ex) {
…
}
...
}
```
**Ответ.** Нет, код корректный. Используется `try-with-resources` соответственно все ресурсы будут зыкрыты,
блок `catch` для обработает исключения.  

51:  Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java
try {
…
}  catch (SomeException е) {
//no code
}
```
**Ответ.** Пустой блок `catch` лишает исключение смысла, который состоит в том, чтобы вы
обрабатывали исключительную ситуацию. Блок `catch` обязан содержать, по крайней мере,
комментарий, объясняющий, почему данное исклю чение следует игнорировать.  
**Источник.** Java TM Эффективное программирование Джошуа Блох стр. 175.  

52: Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java
try {
…
}  catch (SomeException е) {
System.out.println(“Something went wrong!”);
}
```
**Ответ.**  Это вариант предыдущего антипаттерна.  
В данном случае проблема “решается” тем, что о ней сообщается, но вычислительный процесс такое “решение” не восстанавливает.  
**Источник.**  Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 379.  

53: Является ли данный код антипаттерном, если блок `catch` находится не в конце раннер-метода `main()`?  
Обоснуйте ответ.  
```java
try {
…
}  catch (Exception е) {
…
}
…
```
или другой вариант
```java
try {
…
}  catch (Throwable е) {
…
}
…
```
**Ответ.** Нет, блок `catch` может находиться не в конце раннер-метода `main()`.
Однако не используйте `Exception, RuntimeException, Throwable и Error` непосредственно. Рассматривайте эти классы как если бы они были абстрактными. Нельзя надежно протестировать эти исключения, поскольку они являются суперклассами для других исключений, которые может генерировать метод.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 368 с.  

54: Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java
try {
int i = 0;
while(true) {
а[i++].f();
}
} catch(ArraylndexOutOfBoundsException е) {
…
}
```
**Ответ.** `ArrayIndexOutOfBoundsException` - относится к `RuntimeException` такого типа исключения нельзя перехватывать, т.к. в большинстве случаев это ошибка программирования, и подобным образом она скрывается.  

55: Есть ли недостатки у `API` написанного только с использованием обрабатываемых исключений?  
**Ответ.**  
Такое решение оправданно, если даже при надлежащем применении интерфейса `API` невозможно
предотвратить возникновение условий для исключительной ситуации, однако программист,
пользующийся данным `API`, столкнувшись с этим исключением, мог бы предпринять какие-либо
полезные действия. Если не выполняются оба этих условия, лучше пользоваться необрабатываемым
исключением.  
**Источник.** Java TM Эффективное программирование Джошуа Блох стр. 163.


56: Даны два варианта сеттера.  
Какой является более предпочтительным в использовании?  
Обоснуйте ответ.  
Вариант 1.  
```java
void setPositiveValue(int value) {
if(value <= 0) {
throw new IllegalArgumentException(...);
}
this.value = value;
}
```
Вариант 2.  
```java
void setPositiveValue(int value) throws SomeCheckedException {
if(value <= 0) {
throw new SomeCheckedException(...);
}
this.value = value;
}
```
**Ответ.**  Вариант 1.  
Повторное использование имеющихся исключений имеет ряд преимуществ.   
Главное среди них то, что они упрощают изучение и применение ваших `API`, поскольку соответствуют установленным соглашениям, с которыми хорошо знакомы программисты.
С этим же связано второе преимущество, заключающееся в том, что программы, использующие ваш `API`, проще для чтения и понимания, поскольку в них нет незнакомых, сбивающих с толку исключений.
Наконец, чем меньше классов исключений, тем меньше требуется места в памяти и времени на их загрузку.    
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 367 с.  

57: Приведите пример наиболее распространенных из повторно используемых исключений и причины их применения.  
**Ответ.**  **Ответ:**  
1)``IllegalArgumentException`` - Неверное ненулевое значение параметра  
2)``IllegalStateException`` - Неверное состояние объекта для вызова метода  
3)``NullPointerException`` - Неразрешенное нулевое значение параметра  
4)``IndexOutOfBoundsException`` - Индексный параметр за границей допустимого диапазона  
5)``ConcurrentModificationException`` - Обнаружено запрещенное параллельное изменение объекта  
6)``UnsupportedOperationException`` - Объект не поддерживает метод  
**Источник.** Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 369.

58: Если недостаточно информации для принятия решения и...  
1)     исключительная ситуация должна быть исправлена на ближайшем уровне;  
2)     исключительная ситуация маловероятна  
Экземпляры подклассов каких типов исключений целесообразно сгенерировать в каждом случае?  
**Ответ.**  
1) Экземпляры подклассов `Exception`
2) Экземпляры подклассов `RuntimeException`  
   **Источник:**  Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 363.  

59: Выделите в блоке `try-catch` основной и альтернативный сценарии.  
Обоснуйте ответ.  
```java
try {
...
User user = source.getUser(login, password);
if(GUEST_USER.equals(user) {
…
} else {
…
}
...
}  catch (SourceException е) {
…
}
class Source {
public User getUser(String login, String password) throws SourceException {
...
throw new SourceException(...);
...
return GUEST_USER;    //wrong login or password
...
return new User(...);
}
...
}
```
**Ответ.**  Основным сценарием является блок `try`, альтернативным - блок `catch` который сработает при появлении исключения.  

60: Перепишите код предыдущего задания с условием, что ввод неправильных логина или пароля является альтернативным сценарием.  
**Ответ.**  
```java  
        User user = source.getUser(login, password);  
        if (GUEST_USER.equals(user)) {  
                    …  
        } else {  
                    …  
        }  
class Source {  
    public User getUser(String login, String password) {  
                ...  
        return GUEST_USER; // wrong login or password  
                ...  
        return new User();  
    }  
    ...  
}  
```  

61: Что такое трансляция исключения, когда ее используют и какие правила ее использования? Приведите пример трансляции исключения.  
**Ответ.**  
Верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня. Эта идиома известна как трансляция исключений (exception translation):
```java  
// Трансляция исключений  
try {  
... // Применение низкоуровневой абстракции  
} catch (LowerLevelException е) {  
    throw new HigherLevelException(...);  
}  
```  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 370 с.  

62: Как можно избежать использования трансляций и зачем нужно это предпринимать?  
**Ответ.**  Этого можно добиться путем проверки корректности аргументов метода верхнего уровня перед их передачей на нижний уровень.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 372 с.  

63: В каких случаях надо предпочесть сцепление трансляции?  
**Ответ.**  В тех случаях, когда исключение нижнего уровня может быть полезно для анализа ситуации, вызвавшей исключение, лучше использовать особый вид трансляции исключений, называемый цепочкой (сцеплением) исключений (exception chaining).  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 371 с.  

64: Можно ли для исключительной ситуации определить, класс, который не является подклассом `Exception`, `RuntimeException`, `Error`.  
Если да, то как он будет себя проявлять (как `checked-exception` или как `unchecked-exception`)?  
**Ответ.**  Для исключительной ситуации можно определить класс, который не наследует классов `Exception,
RuntimeException и Error`. В спецификации· языка `Java` такие классы напрямую не оговариваются, однако
неявно подразумевается, что они будут вести себя так же, как обычные обрабатываемые исключения
(которые являются подклассами класса `Exception`, но не `RuntimeException`).Однако, желательно не использовать такой класс. Не имея никаких преимуществ перед обычным
проверяемым исключением, он будет только запутывать пользователей вашего API.    
**Источник.** Java: эффективное программирование : Блох, Джошуа – 162 с.

65: Обязательно ли информацию об исключительное ситуации представлять строковым полем?  
Если нет, то какой альтернативный способ создания строкового представления исключения?  
**Ответ.**  
Один из приемов, гарантирующих, что строковое представление исключения будет содержать
информацию, достаточную для Описания сбоя, состоит в том, чтобы эта информация запрашивалась
в конструкторах исключения, а в строке описания. Само же описание исключения можно затем
генерировать автоматически для представления этой информации. Например, вместо конструктора
`String` исключение `IndexOutOfBounds` могло бы иметь следующий конструктор:
```java 
Public IndexOutOfBoundsExoeption(int lowerBound, int index) { 
// Генерируем описание исключения, 
// фиксирующее обстоятельства отказа 
super( "Lower bound: " + lowerBound + 
“,Upper bound: " + uppe rBound + 
“,Index: " + index); 
} 
```
**Источник.** Java: эффективное программирование : Блох, Джошуа – 172 с.

66: Если метод завершается сбоем, что нужно сделать с объектом, на котором был вызван этот метод?  
**Ответ.** Крайне важно, чтобы
метод `toString` в классе исключения возвращал как можно больше информации о причинах отказа.
Иными словами, строковое представление исключения должно зафиксировать отказ для
последующего анализа. Для фиксации сбоя строковое представление исключения должно содержать значения всех
параметров и полей, "способствовавших появлению этого исключения".
**Источник.** Java: эффективное программирование : Блох, Джошуа – 171 - 172 с.  

67: Приведите способы достижения атомарности по отношению к сбоям.  
**Ответ.**   Добиться такого эффекта можно несколькими способами.  
а) Простейший способ заключается в
создании неизменяемых объектов . Если объект неизменяемый, получение атомарности не
требует усилий. Если операция заканчивается сбоем, это может помешать созданию нового объекта,
но никогда не оставит уже имеющийся объект в неопределенном состоянии, поскольку состояние
каждого неизменяемого объекта согласуется в момент его создания и после этого уже не меняется.  
б) Другой прием, который тесно связан с предыдущим и позволяет добиться атомарности по
отношению к сбоям, заключается в упорядочении вычислений таким образом, чтобы все фрагменты
кода, способные повлечь сбой, предшествовали первому фрагменту, который модифицирует объект.
Такой прием является естественным расширением предыдущего в случаях, когда невозможно
произвести проверку аргументов, не выполнив хотя бы части вычислений.  
в) Третий, редко встречающийся прием, заключается в написании специального кода восстановления
(recovery code), который перехватывает сбой, возникающий в ходе выполнения операции, и заставляет
объект вернуться в то состояние, в котором он находился в момент, предшествующей началу
операции.  
г) Наконец, последний прием, позволяющий добиться атомарности метода, заключается в том,
чтобы выполнять операцию на временной копии объекта, и как только операция будет завершена,
замещать содержимое объекта содержимым его временной копии.  
**Источник:** Java: эффективное программирование : Блох, Джошуа – 173 - 174 с.  

68: Приведите пример, когда отсутствие транзакционности в исключениях, приводит к сохранению ссылки на объект в неверном состоянии.  
**Ответ.**  
```java
public class PartialInitTest{

    static PartialInitTest self;

    private int field1 = 0;
    private int field2 = 0;

    public PartialInitTest(boolean fail) throws Exception{
        self = this;
        field1 = 1;
        if (fail) {
            throw new Exception();
        }
        field2 = 1;
    }

    public boolean isConsistent(){
        return field1 == field2;
    }

    public static void main(String[] args){
        PartialInitTest pit = null;
        try {
            pit = new PartialInitTest(true);
        } catch (Exception ex){
            // do nothing
        }
        System.out.println("pit: "+pit);
        System.out.println("PartialInitTest.self reference: "+PartialInitTest.self);
        System.out.println("PartialInitTest.self.isConsistent(): "+PartialInitTest.self.isConsistent());
    }
}
```
В конструкторе мы присваиваем ссылку на созданный объект статической переменной. Дальше мы инициализируем одно поле и... бросаем исключение.  
**Источник.**  http://skipy.ru/technics/exceptions.html#tcf

69: Необходимо создать коллекцию из результатов тестов, находящихся в валидном файле `src/in.csv`.  
Пример файла  
```java
cool;75;90
clever;68;95
looser;30;48
```
Является ли код, реализующий задание, антипаттерном?  
Обоснуйте ответ.  

```java
public class Runner {
public static void main(String[] args) {
List<Trial> trials = new ArrayList<Trial>();
try(Scanner sc = new Scanner(new FileReader("src/in.csv"))) {
while(sc.hasNext()) {
Trial trial = getTrial(sc);
trials.add(trial);
}
printTrials(trials);
} catch (FileNotFoundException e) {
System.out.println(Constants.ERROR_FILE_FOUND);
}
}
private static Trial getTrial(Scanner sc) {
String csvLine = sc.nextLine();
String[] values = csvLine.split(Constants.DELIMETER);       
try {
String name = values[Constants.NAME_INDEX];
int mark1 = Integer.parseInt(values[Constants.MARK1_INDEX]);
int mark2 = Integer.parseInt(values[Constants.MARK2_INDEX]);
return new Trial(name, mark1, mark2);
} catch (CsvLineException e) {
System.out.println(Constants.ERROR_WRONG_DATA);
}
}
```
**Ответ.**  
Данный код является антипаттерном т.к. исключение перехватывается внутри метода и такой перхват будет игнорировать ошибку.   
В случае ошибки в методе `getTrial` метод не будет ничего возвращать. Т.к. в блоке `catch` не прописан альтернативный сценарий для возвращения элемента.  

70: Приведите пример кода собственного исключения (реализация в одном классе всего нижеперечисленного). Класс исключения содержит:  
- поле, которым является неправильная строка, считанная из файла (имя `csvLine`);  
- конструктор по умолчанию, вызывающий конструктор суперкласса;  
- параметризованный конструктор, принимающий экземпляр исключения и неправильную строку, считанную из файла;  
- параметризованный конструктор, принимающий строку с указанием причины исключения и  неправильную строку, считанную из файла;  
- геттер с возвратом неправильной строки;  
- переопределенного метода `toString` с указанием неправильной строки и метода вывода сообщения об ошибки.  
**Ответ.**  
```java 
public class SomeCsvLineException extends Exception {
private String wrongCsvLine;
public SomeCsvLineException() {
super();
}
public SomeCsvLineException(String message, String wrongCsvLine) {
super(message);
this.wrongCsvLine = wrongCsvLine;
}
public SomeCsvLineException(Throwable cause, String wrongCsvLine) {
super(cause);
this.wrongCsvLine = wrongCsvLine;
}
public String getWrongCsvLine() {
return wrongCsvLine;
}
@Override
public String toString() {
return wrongCsvLine + super.toString();
}
}
```

71: Необходимо создать метод для экспорта `csv`-файла в коллекцию.  
При наличии хотя бы одной ошибки в исходных данных “отменить” создание
коллекции.  
Какие антипаттерны содержит следующий код?  
Предложите варианты по избавлению от них.  
```java
private static List<Trial> getTrials(Scanner sc) {
List<Trial> trials = new ArrayList<Trial>();
try {
while(sc.hasNext()) {
Trial trial = getTrial(sc);
trials.add(trial);
}
} catch (CsvLineException e) {
System.err.println(e);
}
return trials;
}
```
**Ответ.** Если во время цикла случится сбой, колекция, наполненная экземплярами класса `Trial` по прежнему будет существовать.    
Таким образом метод вернет не пустую коллекцию а частично заполненную, чтоб избежать этого в блоке `catch` коллекции стоит присвоить новую (пустую) коллекцию которая после будет возвращена методом.  

72: Создать метод для экспорта данных в коллекцию из последовательного источника экземпляров `Trial`.  
См. код ниже.  
Его необходимо дополнить, чтобы происходила обработка следующих исключительных ситуаций:
73: Файл не найден.
74: Ошибка в `csv` строке.
Примечание: код не должен нарушать принцип “верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня”
См. Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 370.
Считается, что классы для исключений созданы и имеют необходимый функционал.
Подсказка:
---
Надо использовать два исключения. Одно из которых будет нижнего уровня, другое верхнего уровня.
---
Еще одна подсказка:
---
Одно из исключений обрабатываемое, другое нет.
---

//начало кода, реализующего задание
//---
```java
interface TrialProvidable {
boolean hasTrial();
Trial getTrial();
}

public class TrialCsvImpl implements TrialProvidable {
private Scanner sc;
public CsvImpl(String csvName) {                
sc = new Scanner(new FileReader(csvName));
}
public boolean hasTrial() {                 
return sc.hasNextLine();
}
public Trial getTrial() {
// get Trial instance from csv line
return trial;
}
}

public class Runner {
private static List<Trial> getTrials(TrialProvidable trialProvider) {
List<Trial> trials = new ArrayList<Trial>();
while(trialProvider.hasTrial()) {
Trial trial = trialProvider.getTrial();
trials.add(trial);
}
return trials;
}

public static void main(String[] args) {
TrialProvidable trialProvider = null;
try {
if("csv".equals(args[0])) {
trialProvider = new TrialCsvImpl("src/in.csv");
} else {
trialProvider = new TrialDBImpl();
}
List<Trial> trials = getTrials(trialProvider);
…
} finally {
if (trialProvider != null) {
trialProvider.close();
}
}
}
}
```
//---
//конец кода, реализующего задание  
**Ответ.**  
```java  
  public interface TrialProvidable {  
boolean hasTrial();  
Trial getTrial() throws CsvLineException;  
void close();  
}
public class TrialCsvImpl implements TrialProvidable {  
private Scanner sc;
    public TrialCsvImpl(String csvName) {  
        try {  
            sc = new Scanner(new FileReader(csvName));  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
    }  
  
    @Override  
    public boolean hasTrial() {  
        return sc.hasNextLine();  
    }  
  
    @Override  
    public Trial getTrial() throws CsvLineException {  
        Trial trial = null;  
        String line = sc.nextLine();  
        try {  
            String name = sc.next();  
            int age = (int) Integer.parseInt(sc.next());  
            trial = new Trial(name, age);  
        } catch (NumberFormatException e) {  
            throw new CsvLineException(e.getMessage(), line);  
        }  
        return trial;  
    }  
  
    @Override  
    public void close() {  
        sc.close();      
    }  
}
public class Runner {
    private static List<Trial> getTrials(TrialProvidable trialProvider) {  
        List<Trial> trials = new ArrayList<Trial>();  
        while (trialProvider.hasTrial()) {  
            Trial trial = null;  
            try {  
                trial = trialProvider.getTrial();  
            } catch (CsvLineException e) {  
                e.printStackTrace();  
            }  
            if (trial != null) {  
                trials.add(trial);  
            }  
        }  
        return trials;  
    }  
  
    public static void main(String[] args) {  
        TrialProvidable trialProvider = null;  
        try {  
            if ("csv".equals(args[0])) {  
                trialProvider = new TrialCsvImpl("src/in.csv");  
            } else {  
                trialProvider = new TrialDBImpl();  
            }  
            List<Trial> trials = getTrials(trialProvider);  
//          ...  
} finally {  
if (trialProvider != null) {  
trialProvider.close();  
}  
}  
}  
}
```  