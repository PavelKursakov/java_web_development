1) В какой версии Java появились параметризованные типы?  
**Ответ.**
   `Java Generics` — это одно из самых значительных изменений за всю историю языка Java. «Дженерики», доступные с Java 5, сделали использование `Java Collection Framework` проще, удобнее и безопаснее.  
**Источник.**  https://habr.com/ru/company/sberbank/blog/416413/

2) Приведите 2 примера кода: первый без параметризованного типа; второй - этот же код с параметризованным типом, иллюстрирующий преимущество данного варианта.  
**Ответ.**
а) Пример без параметризованного типа:  
```java
public long getSum(List accounts) {
   long sum = 0;

   for (int i = 0, n = accounts.size(); i < n; i++) {
       Object account = accounts.get(i);
       if (account instanceof Account) {
           sum += ((Account) account).getAmount();
       }
   }

   return sum;
}
```
Если не сделать проверку `(instanceof)` на принадлежность к классу `Account`, то на втором этапе возможен` ClassCastException` – то есть аварийное завершение программы. Поэтому такая проверка была обязательной.

б) Пример этого же кода с параметризованным типом:  
```java
public long getSum2(List<Account> accounts) {
   long sum = 0;

   for (Account account : accounts) {
       sum += account.getAmount();
   }

   return sum;
}
```
С появлением `Generics` необходимость в проверке и приведении типа отпала.  

3) Какие типы данных запрещены в качестве параметров классов?  
**Ответ.** Переменная типа может быть любым указанным вами непримитивным типом: любым типом класса, любым типом интерфейса, любым типом массива или даже переменной другого типа. В качестве параметров запрещено определять базовые типы данных.  
**Источник.**  Java 2: практ. рук. / И.Н. Блинов, В.С. Романчик. – Мн.: УниверсалПресс, 2005. стр. 53.  
https://docs.oracle.com/javase/tutorial/java/generics/types.html

4) Дан код:
```java
class Gen <T1, T2 extends Number, T3 extends Object> { … }
```
Какие типы можно использовать в качестве аргументов `T1`, `T2`,`T3`?  
**Ответ.**
а) В качестве аргумента `T1` можно использовать любые типы, кроме базовых.  
б) Запись `T2 extends Number` говорит о том, что в качестве типа `Т2` разрешено применять только классы, являющиеся наследниками класса `Number`.  
в) Поскольку `T2 extends Object` в качестве `Т3` мы можем передавать любые типы, при условии, что это не один из примитивных типов.  

5) Дан код:
```java
class Gen1 <T> { … }
class Gen2 <T extends Object> { … }
class Runner {
private final static Gen1<Object> g11 = new Gen1<>();
private final static Gen1 g12 = new Gen1();
private final static Gen2<Object> g21 = new Gen2<>();
private final static Gen2 g22 = new Gen2();
...
}
```  
а) В чем различие объявления классов `Gen1` и `Gen2`?  
б) Есть ли преимущество в объявлении `g11` по сравнению с `g12`? Обоснуйте ответ.  
в) Есть ли преимущество в объявлении `g21` по сравнению с `g12`? Обоснуйте ответ.  
г) В каком случае используется второй способ (`g12, g22`)?  
**Ответ.**  
а) `Gen1` и `Gen2` не имеют никакого различия, так как` <T>` и `<T extends Object>` эквивалентны. `<T>` по умолчанию предполагает класс `T` наследуется от класса `Object`.  
б) Да, если фактический аргумент типа опущен, вы создаете необработанный тип. В нашем случае это `g12` Необработанные типы `Raw types` обходят проверки универсального типа, откладывая обнаружение небезопасного кода во время выполнения. Следовательно, нам следует избегать использования необработанных типов. Таким образом `g12` "условно" отказался от проверки универсального типа, в то время как `g11` явно сказал компилятору, что он способен содержать объекты любого типа.  
в) Да (смотреть ответ `б)`). `g12` Необработанный тип `Raw type`.  
г) Использование необработанных типов допускается только в качестве уступки совместимости устаревшего кода. Из-за непатентованного универсального кода `Java` есть два исключения, где необработанные типы должны использоваться в новом коде:  
1: Литералы класса, например `List.class`, не `List<String>.class`  
2: `instanceof` операнд, например o `instanceof Set`, не o `instanceof Set<String>`    
**Источник.**  И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 91  
https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html   
https://qastack.ru/programming/2770321/what-is-a-raw-type-and-why-shouldnt-we-use-it

6) Дан код:
```java
class SubInfo extends Info { … }
class Gen1 <T> { … }
class Gen2 <T extends Info> { … }
```
а) Является ли декларация `Gen1<Info>` подклассом `Gen2<Info>`?  
б) Является ли декларация `Gen1<SubInfo>` подклассом `Gen1<Info>`?  
в) Является ли декларация `Gen2<SubInfo>` подклассом `Gen2<Info>`?  
**Ответ.**  
а) Нет , общим родителем `Gen2<Info>` и `Gen1<Info>` является класс `Object`.  
б) Нет, Учитывая два конкретных типа `SubInfo` и `Info`, `Gen1<Info>` не имеет отношения к `Gen1<SubInfo>`, независимо от того, связаны ли `SubInfo` и `Info`. Общим родителем `Gen1<SubInfo>` и `Gen1<Info>` является `Object`.  
в) Нет, смотреть ответ `a)`  
Во всех случаях `Gen2<>` и `Gen1<>` являются подклассами класса `Object`.  
**Источник.**  https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html  

7) Почему нельзя вызвать конструктор `generic-типа`?  
**Ответ.**  
Для `generic-типов` существует ряд ограничений. Например, невозможно выполнить явный вызов конструктора `generic-типа`:  
```java
class FailedOne <T> {
private T value = new T();
}
```
Компилятор не знает, какой конструктор может быть вызван и какой объем памяти должен быть выделен при создании объекта.  
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 91  

8) Почему нельзя создать `generic-поле`?  
**Ответ.** Статическое поле класса - это переменная уровня класса, совместно используемая всеми нестатическими объектами класса. Следовательно, статические поля параметров типа не допускаются.  
**Источник.**  https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html  

9) Почему статический метод не может иметь `generic-параметр`?  
**Ответ.**  Если метод статический, то унаследовать параметр типа от класса он не может. Это вызвано тем, что параметр типа привязывается к конкретному объекту при его создании, а статический метод не привязан к конкретному объекту, он привязан к классу в целом. В случае статического метода параметр типа нужно указывать непосредственно перед объявлением метода:  
```java
public class A {
    public static <T> void doSth(T t) {
        System.out.println(t.getClass().getName());
    }
}

A.doSth("abc");         // выведет java.lang.String
A.doSth(123);           // выведет java.lang.Integer
```
В этом случае тип `T` определяется в момент вызова статического метода по типу передаваемого аргумента.  

10) Предложите более эффективную запись данного кода:
```java
<T> void make1(Gen <T extends Object> gen) { … }
<T, S extends T> void make2(Info<T> info1, Info<S> info2) { … }
```  
**Ответ.**  
```java
<T> void make1(Gen <?> gen) {...}
<T> void make2(Info<T> info1, Info<? extends T> info2) { … }
```

11) Дан код:
```java
class Info {
public <T1> Info() { … }
public <T2> Info(T2 t2) { … }
public <T1> void make1(T1 t1) { … }
public <T3> void make2() { … }
}
```
Создайте какой-либо экземпляр класса `Info`  
а) конструктором без аргументов,  
б) конструктором с аргументом.  
в) Синтаксически правильно вызовите методы` make1()` и `make2()`.  

**Ответ.** Т.к. в данном примере сам класс `Info` не определен как обобщенный, а конструктор определен таковым, создание экземпляров класса `Info` будет выглядеть как в примере ниже.
В данном примере методы `make1` и `make2` определены как обобщенные их синтаксически правильный вызов будет выглядеть следующим образом:  
```java
class Info {
public <T1> Info() { … }
public <T2> Info(T2 t2) { … }
public <T1> void make1(T1 t1) { … }
public <T3> void make2() { … }

    public static void main(String[] args) {
        Info info1 = new <T1>Info();
        Info info2 = new Info(new T2());
        String making = "I'm making something";
        info1.make1(making); //implicit generic <String>
        info2.make2();
    }
}
```
Как можно понять из примера `info2` может вызывать метод `make()` не указывая тип `<String>` т.к. он определяется неявно с помощью строки `making` переданной в метод.  
**Источник.**  https://metanit.com/java/tutorial/3.11.php  

12) Поясните данный код:
```java
static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
```  
**Ответ.**  Это универсальный статический метод, параметризованный `<T extends Object & Comparable<? super T>` >` Multiple Bounds` – множественные ограничения. Записывается через символ `&`, то есть мы говорим, что тип, представленный переменной типа `T`, должен быть ограничен сверху классом. `Object` и интерфейсом `Comparable`. Возвращаемое значение метода объект класса `T`.
    В качестве аргумента max принимается коллекция, которая инициализируется объектами классов-наследников класса T.  
**Источник.**  https://habr.com/ru/company/sberbank/blog/416413/  
И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 68-73
