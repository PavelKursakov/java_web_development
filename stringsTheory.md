Вопрос 1.
Что появится в консоли в результате работы фрагмента программы?
String a = "java";
a.toUpperCase();
System.out.println(a);
**Ответ.** Метод `toUpperCase()` поднимает все символы строки в верхний регистр. Однако т.к. класс ```String```
неизменяемый этот метод не поменяет переменную `a`. Для ее изменения следует прописать `a = a.toUpperCase()`.
Вывод в консоль будет следующим:
```java```

Вопрос 2.
Что появится в консоли в результате работы фрагмента программы?
String s1 = "Java";  
String s2 = "Java";  
String s3 = new String("Java");  
System.out.println("s1 == s2 : " + (s1 == s2));  
System.out.println("s1 == s3 : " + (s1 == s3));  
System.out.println(s1.equals(s3));  
Поясните ответ.  
**Ответ.**  
При создании экземпляра класса String путем присваивания его ссылки
на литерал, последний помещается в так называемый «пул литералов». Если
в дальнейшем будет создана еще одна ссылка на литерал, эквивалентный ранее
объявленному, то будет произведена попытка добавления его в «пул литералов». Так как идентичный литерал там уже существует, то дубликат не может
быть размещен, и вторая ссылка будет на существующий литерал, такой принцип отслеживается при создании строки ```s2```.
При сравнении строк через оператор ```==``` сравниваются их ссылки и в первом случае ```s1``` имеет ту же ссылку что и ```s2```.
Однако ```s3``` имеет другую ссылку.
При сравнении строк через метод ```equals()``` сравниваются значения. Соответственно вывод будет следующим:
```java 
s1 == s2 : true 
s1 == s3 : false
true
```
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 173-174  

Вопрос 3.
Можно ли выполнить наследование от класса String?  
Почему?  
**Ответ.**  
Нет, т.к. класс ```String``` является финальным (неизменным) классом.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/strings.html  

Вопрос 4.
Назовите основные, на ваш взгляд, методы класса String.  
**Ответ.**
```java 
String s = "Hello, EPAM!"
String concat(String s) или «+» — слияние строк;
boolean equals(Object ob) и equalsIgnoreCase(String s) — сравнение строк 
с учетом и без учета регистра соответственно;
int compareTo(String s) и compareToIgnoreCase(String s) — лексикографи-
ческое сравнение строк с учетом и без учета их регистра. Метод осуществляет 
вычитание кодов первых различных символов вызывающей и передаваемой 
строки в метод строк и возвращает целое значение. Метод возвращает значе-
ние нуль в случае, когда equals() возвращает значение true;
boolean contentEquals(StringBuffer ob) — сравнение строки и содержимо-
го объекта типа StringBuffer;
String substring(int n, int m) — извлечение из строки подстроки длины 
m-n, начиная с позиции n. Нумерация символов в строке начинается с нуля;
String substring(int n) — извлечение из строки подстроки, начиная с позиции n;
int length()— определение длины строки;
int indexOf(char ch)— определение позиции символа в строке;
static String valueOf(значение) — преобразование переменной базового 
типа к строке;
String toUpperCase()/toLowerCase()— преобразование всех символов вы-
зывающей строки в верхний/нижний регистр;
String replace(char с1, char с2) — замена в строке всех вхождений первого 
символа вторым символом;
String intern() — заносит строку в «пул» литералов и возвращает ее объект-
ную ссылку;
String trim() — удаление всех пробелов в начале и конце строки;
char charAt(int position) — возвращение символа из указанной позиции 
(нумерация с нуля);
boolean isEmpty() — возвращает true, если длина строки равна 0;
char[] getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) — извле-
чение символов строки в массив символов;
static String format(String format, Object… args), format(Locale l, String
format, Object… args)— генерирует форматированную строку, полученную 
с использованием формата, интернационализации и др.;
String[] split(String regex), String[] split(String regex, int limit) — поиск 
вхождения в строку заданного регулярного выражения (разделителя) и деле-
ние исходной строки в соответствии с этим на массив строк.
```
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 171

Вопрос 5.
Какие разновидности конструкторов использует класс String?  
**Ответ.**  Класс ```String``` поддерживает несколько конструкторов, например: ```String(),
String(String str), String(byte[] asciichar), String(char[] unicodechar),
String(StringBuffer sbuf), String(StringBuilder sbuild) и др.``` Эти конструкторы
используются для создания объектов класса String на основе инициализации
значениями из массива типа char, byte и др. Например, при вызове конструктора
```java 
new String(str.getBytes(), "UTF-8")
```
можно установить кодировку создаваемому экземпляру в качестве второго
параметра конструктора. Когда Java встречает литерал, заключенный в двойные
кавычки, автоматически создается объект-литерал типа String, на который можно установить ссылку. Таким образом, объект класса String можно создать, при-
своив ссылке на класс значение существующего литерала или с помощью оператора ```new``` и конструктора, например:
```java 
String s1 = "oracle.com";
String s2 = new String("oracle.com");
``` 
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 170-171

Вопрос 6.
Какие классы в стандартной библиотеке Java работают со строками?  
**Ответ.**  
Реализация строк на Java представлена тремя основными классами: ```String```, ```StringBuffer```, ```StringBuilder```.  
класс ```java.lang.String``` является неизменяемым ```(immutable)``` — созданный объект класса ```String``` не может быть изменен. Методы могут только создавать и возвращать новые строки, в которых хранится результат операции.  
Классы ```StringBuilder и StringBuffer``` являются «близнецами» и по своему
предназначению близки к классу ```String``` , но в отличие от последнего содержимое и размеры объектов классов ```StringBuilder и StringBuffer``` можно изменять.
С помощью соответствующих методов и конструкторов объекты классов
```StringBuffer, StringBuilder и String``` можно преобразовывать друг в друга.
Так же со строками работают классы ``` Formatter, Matcher, Pattern```  
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 174   
https://habr.com/ru/post/260767/

Вопрос 7.
Почему экземпляры класса String в Java неизменные и финализированные?  
**Ответ.**  
Есть несколько преимуществ в неизменности строк:  
а) Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти(heap space), поскольку разные строковые переменные указывают на одну переменную в пуле.  
б) Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения.  
в) Так как строка неизменная, она безопасна для многопоточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности, строки полностью потокобезопасны.  
г) Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader.  
д) Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект в качестве ключа HashMap.  
**Источник.**  https://javastudy.ru/interview/strings/

Вопрос 8.
Заполните ячейки таблицы (Да/Нет).  
```Characteristic``` 				```String```		```StringBuilder```		```StringBuffer```  
Неизменяемый ```(Immutable)```?  
Имеет пул ```(Pooled)```?  
Потокобезопасный ```(Thread-safe)```?  
Может изменять размер?  
**Ответ.**  
Characteristic 				```String```		```StringBuilder```		```StringBuffer```  
Неизменяемый ```(Immutable)```?   да          нет                 нет  
Имеет пул ```(Pooled)```?         да          нет                 нет  
Потокобезопасный ```(Thread-safe)```?  да     нет                 даа, за счет синхронизации  
Может изменять размер?      нет         да                  да  
**Источник.**  https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java   
https://docs.oracle.com/javase/tutorial/java/data/buffers.html  

Вопрос 9.
В чем разница и что общего между ```StringBuffer``` и ```StringBuilder```?  
**Ответ.**  
Разница лишь в том, что ```StringBuffer``` потокобезопасен, и все его методы синхронизированы, а ```StringBuilder``` — нет. Это единственная особенность.  
```StringBuilder``` в ```Java``` работает быстрее ```StringBuffer’а``` благодаря несинхронизированности методов.  
**Источник.**  https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java  

Вопрос 10.
Когда лучше использовать ```StringBuffer```, а когда ```StringBuilder```?  
**Ответ.**   
В большинстве случаев, кроме многопоточной среды, лучше использовать для программы на ```Java``` ```StringBuilder```. ```StringBuilder``` следует применять, если не существует вероятности использования объекта в конкурирующих потоках для получения более высокой скорости обработки.
В остальных случаях лучше использовать ```StringBuffer```.  
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 174  
https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java

Вопрос 11.
Какие методы имеются в классах StringBuffer и StringBuilder, которые отсутствуют в классе String?  
**Ответ.**   
В ```StringBuilder``` классе есть некоторые методы, связанные с длиной и емкостью, которых ```String``` нет в классе:  
а)
```java
void setLength(int newLength)
```
Устанавливает длину последовательности символов. Если ```newLength``` меньше ```length()```, последние символы в последовательности символов усекаются. Если ```newLength``` больше ```length()```, в конце последовательности символов добавляются нулевые символы.  
б)
```java
void ensureCapacity(int minCapacity)
```
Гарантирует, что емкость по крайней мере равна указанному минимуму.  
Основные операции над a ```StringBuilder```, недоступные в ```String```, — это методы ```append()``` и ```insert()```, которые перегружены, чтобы принимать данные любого типа. Каждый преобразует свой аргумент в строку, а затем добавляет или вставляет символы этой строки в последовательность символов в построителе строк. Метод append всегда добавляет эти символы в конец существующей последовательности символов, а метод вставки добавляет символы в указанную точку.  
А так же методы:  
```StringBuffer deleteCharAt(int index)``` — удаление символа;  
```StringBuffer delete(int start, int end)``` — удаление подстроки;  
```StringBuffer reverse()``` — обращение содержимого объекта.   
**Источник.** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 175  
https://docs.oracle.com/javase/tutorial/java/data/buffers.html  

Вопрос 12.
Какие методы сравнения строк имеются в строковых классах?  
**Ответ.**  
а)  
```boolean endsWith(String suffix)```
```boolean startsWith(String prefix)```	Возвращает, ```true``` если эта строка заканчивается или начинается с подстроки, указанной в качестве аргумента метода.  
б)  
```boolean startsWith(String prefix, int offset)```	Считает строку, начинающуюся с индекса ```offset```, и возвращает, ```true```если она начинается с подстроки, указанной в качестве аргумента.  
в)  
```int compareTo(String anotherString)```	Сравнивает две строки лексикографически. Возвращает целое число, указывающее, больше ли эта строка (результат> 0), равна (результат = 0) или меньше (результат <0) аргумента.  
г)  
```int compareToIgnoreCase(String str)```	Сравнивает две строки лексикографически, игнорируя различия в регистре. Возвращает целое число, указывающее, больше ли эта строка (результат> 0), равна (результат = 0) или меньше (результат <0) аргумента.  
д)  
```boolean equals(Object anObject)```	Возвращает, ```true``` если и только если аргумент является ```String``` объектом, который представляет ту же последовательность символов, что и этот объект.  
е)  
```boolean equalsIgnoreCase(String anotherString)```	Возвращает, ```true``` если и только если аргумент является ```String``` объектом, который представляет ту же последовательность символов, что и этот объект, игнорируя различия в регистре.  
ж)  
```boolean regionMatches(int toffset, String other, int ooffset, int len)```	Проверяет, соответствует ли указанная область этой строки указанной области аргумента ```String```.
Область имеет длину ```len``` и начинается с индекса ```toffset``` для этой строки и ```ooffset``` для другой строки.  
з)  
```boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)```	Проверяет, соответствует ли указанная область этой строки указанной области аргумента ```String```.
Область имеет длину len и начинается с индекса ```toffset``` для этой строки и ```ooffset``` для другой строки.
Логический аргумент указывает, следует ли игнорировать регистр; если истина, то при сравнении символов регистр игнорируется.  
и)  
```boolean matches(String regex)```	Проверяет, соответствует ли эта строка указанному регулярному выражению. Регулярные выражения обсуждаются в уроке «Регулярные выражения».  
**Источник:** https://docs.oracle.com/javase/tutorial/java/data/comparestrings.html

Вопрос 13.
Используя функции строковых классов, написать фрагмент программы, которая будет определять, является ли строка палиндромом.
**Ответ.**
```java 
public boolean checkPolyindrome(String s)
StringBuilder sb = new StringBuilder(s);
return sb.toString().equals(sb.reverse().toString());
```
Данный метод будет определять, является ли строка палиндромом с помощью метода ```reverse()``` класса ```StringBuilder```  

Вопрос 14.
Что появится в консоли в результате работы фрагмента программы?  
```java
final String ZA = " за ";
String value = "ОТЧЕТ о перевозках пассажиров за январь 2019 г.";
String[] monthYear = value.split(ZA)[1].split(" ",3);
System.out.println(Arrays.toString(monthYear));
```
Поясните ответ.  
**Ответ.**  
Основная операция происходит в строке ```String[] monthYear = value.split(ZA)[1].split(" ",3);```
Используя метод ```split(ZA)``` создается массив элементам которого являются части строки до и после строки "за".
Далее ```[1]``` является индексом созданного массива, следующий вызов метода ```split()``` делает слудющее:  
Разделяет строку под индексом 1 первого массива на подстроки, разделителем является символ пробел, таким образом создается второй массив из слов, которые в строке разделены пробелами.
```limit 3``` указывается в методе ```split()``` указывает кол-во элементов которые будут разделены пробелами, по порядку.
Последняя строка фрагмента выводит в консоль все элементы массива объеденяя их в одну строку. Вывод будет следующим:  
```[январь, 2019, г.]```  

Вопрос 15.
Что появится в консоли в результате работы фрагмента программы?  
String s4 = "1" + 2 + 3;  
String s5 = 1 + 2 + "3";  
System.out.println(s4);  
System.out.println(s5);  
Поясните ответ.  
**Ответ.**  
**Ответ:**  
Первая строка создается с "1" таким образом следующие операции сложения трактуются как объединение строк.  
Вторая строка начинается с арифметической операции сложения, таким образом объединение строк происходит уже после вычисления арифметической операции,
т.е. в учатке ```+ "3"```
Вывод в консоль будет следующим:
```
123
33
```


Вопрос 16.
Что появится в консоли в результате работы фрагмента программы?  
```java
String s = "abcde ";  
System.out.println(s.trim().length());  
System.out.println(s.charAt(4));  
System.out.println(s.indexOf('e'));  
System.out.println(s.indexOf("de"));  
System.out.println(s.substring(2, 4).toUpperCase());  
System.out.println(s.replace('a', '1'));  
System.out.println(s.contains("DE"));  
System.out.println(s.startsWith("a"));
```  
Поясните ответ.  
**Ответ.**  
```java
5  //метод trim() удаляет пробелы в начале и в конце строки, таким образом выводится длинна строки без последнего пробела
e  //метод charaAt() получает символ под индексом который был передан, т.е. под индексом 4
4  //метод indexOf('e') получает индекс символа , который был передан, т.е. по символу 'e'
3  //метод indexOf("de") работает так же как и предыдущий аналог только принимает строку
CD //метод substring() вырезает строку по индексам которые были переданы (2,4) где первый индекс - начало новой строки, второй индекс конец строки (не включительно)
метод toUpperCase() поднимает все символы строки в верхний регистр
1bcde //метод replace() заменяет символ 'a' в строке на символ '1'
false //метод contains("DE") проверяет есть ли в строке подстрока "DE" и выводит false если такая подстрока не была найдена
true  //методе startsWith() определяет, начинается ли заданная строка с указанной символьной строки "a"
```  

Вопрос 17.
Что появится в консоли в результате работы фрагмента программы?  
```java
StringBuilder b = new StringBuilder();
b.append(12345).append('-');
System.out.println(b.length());
System.out.println(b.indexOf("-"));
System.out.println(b.charAt(2));
StringBuilder b2 = b.reverse();
System.out.println(b.toString());
System.out.println(b == b2);
```
Поясните ответ.  
**Ответ.**  
```java
//В первой строке мы создаем объект типа StringBuilder с именем b; 
// Мы используем данный класс т.к. у него есть удобный для нас метод revece();
// С помощью метода append(12345) мы задаем значение нашему объекту b, который до этого действия был "пустым". 
// Функционал метода append можно описать как "добавить к строке".
//метод append('-') добавляет символ к строке объекта, то есть добавляет в конец строки символ '-'
6 - Выводит длину b с учетом уже добавленного символа '-'
5 - метод indexOf() возвращает индекс добавленного символа '-'
3 - метод charAt() возвращает символ который имеет переданный индекс (2)
-54321 - метод revers() заменяет строку на его зеркальный вариант, метод toString() выводит объект в виде строки 
true - т.к. ссылка на объект b не изменилась, опертатор сравнения "==" возвращает true
```  

Вопрос 18.
Что появится в консоли в результате работы фрагмента программы?  
```java
StringBuilder s = new StringBuilder("abcde");
s.insert(1, '-').delete(3, 4);
System.out.println(s);
System.out.println(s.substring(2, 4));
```
Поясните ответ.  
**Ответ.**  
```java
//метод insert вставляет элемент присваивая ему переданный индекс не заменяя предыдущий символ под этим индексом, а отодвинув все индексы справа на одну ячейку,
 в данном случае вставляется символ '-' под индексом 1 
a-bde // т.к. в предыдущей строке кода был вставлен новый символ, символ 'c' теперь получил индекс 3, метод delete()
удаляет все символы начиная от первого переданного индекса заканчивая вторым переданным индексом (не включительно), таким образом 
был удален символ под индексом 3, то есть символ 'c'
bd метод substring() обрезает строку начиная с первого переданного индекса до последнего символа с переданным индексом (не включительно)
```  

Вопрос 19.
```java
StringBuffer sb = new StringBuffer("abcde");
sb.insert(2,"123");
sb.append("456");
sb.reverse();
```
Поясните ответ.  
**Ответ:**
```java
//методы StringBuffer работают аналогично методам StringBuilder
sb.insert(2,"123"); //метод insert() вставит новую строку "123" начиная с переданного символа.
подвинув каждый элемент внутренней строки на "123".length ячеек вправо. sb при выводе: ab123cde
sb.append("456"); // метод append() добавит строку "456" к внутренней строке объекта sb. sb при выводе ab123cde456 
sb.reverse(); // метод reverse() зеркально отразит строку. sb при выводе : 654edc321ba 
```

Вопрос 20.
Каким образом можно сцепить строки Java?  
Назовите не менее 3 способов.  
**Ответ.**   
а) С помощью оператора ```+```  
б) С помощью метода ```concat()``` — возвращает строку со значением строки, переданной в метод и приложенной к концу строки, используемой для вызова этого метода.  
в) С помощью ```StringBuilder``` класса. Пример:
```java 
String hello = "Hello, ";
String world = "world";
String helloWorld = new StringBuilder(hello).append(world).toString();
```  
г) С помощью ```StringBuffer``` класса. Пример:
```java 
String hello = "Hello, ";
String epam = "EPAM";
String helloEpam = new StringBuffer(hello).append(epam).toString();
```  

Вопрос 21.
Чем отличаются пустая и нулевая строки?  
**Ответ.** Пустая строка - это экземпляр строки нулевой длины, тогда как null строка вообще не имеет значения.
Пустая строка (например, "") означает, что была создана строковая константа (неважно, что она пустая), и под нее было выделено определенное количество памяти.
Нулевая строка (null) не требует выделения под нее памяти.  
**Источник:**   https://docs.oracle.com/javaee/7/tutorial/bean-validation002.htm  

Вопрос 22.
В какой кодировке хранятся символы в строке?  
**Ответ.**  
Строки - это объекты, которые обычно содержат массив char и длину строк. Массив символов обычно реализуется как непрерывный массив из 16-битных слов, каждый из которых содержит символ Unicode в собственном порядке байтов.  

Вопрос 23.
Какие интерфейсы реализуют классы String, StringBuffer и StringBuilder?  
**Ответ.**  
Классы ```String```, ```StringBuffer```, ```StringBuilder``` определены в пакете `java.lang` и доступны автоматически без объявления импорта. Все три класса реализуют интерфейс `CharSequence`.  
Так же `String` реализует интерфейсы `Serializable` и  `Comparable<String>`;
`StringBuffer` и `StringBuilder` реализуют интерфейсы ```Serializable, Appendable```.  
**Источник.**  https://javarush.ru/groups/posts/1411-klass-string  
https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html  

Вопрос 24.
Что такое кодовые точки и кодовые единицы?  
**Ответ.**  
Единица кода - это 16-битный двоичный код, а кодовая точка - это один или два 16-битных двоичного кода. То есть одна кодовая точка может быть выражена как одна кодовая единица или две кодовые единицы.  
Кодовая точка относится к числу, соответствующему символу в кодированном наборе символов. Допустимый диапазон от U + 0000 до U + 10FFFF. Среди них от U + 0000 до U + FFFF - основные символы, а от U + 10000 до U + 10FFFF - дополнительные символы.  
Единица кода: 1 или 2 16-битные последовательности, полученные путем кодирования кодовых точек. Кодовая точка основного символа напрямую представлена ​​кодовой единицей того же значения, а кодовая точка дополнительного символа кодируется двумя кодовыми единицами.  
**Источник.**  https://russianblogs.com/article/56331560288/

Вопрос 25.
Объясните назначение метода intern().
Что появится в консоли в результате работы фрагмента программы?
```java
class GFG {
public static void main(String[] args) {
String s1 = new String("GFG");
String s2 = s1.intern();
System.out.println(s1 == s2);
System.out.println(s1.equals(s2));
String s3 = "GFG";
System.out.println(s2 == s3);
}
}
```
Поясните ответ.  
**Ответ.**  
```String intern()``` — заносит строку в «пул» литералов и возвращает ее объект-
ную ссылку. Вызов метода ```intern()``` организует поиск в «пуле литералов» соответствующего значению объекта
литерала и при положительном результате возвращает ссылку на найденный
литерал, а при отрицательном — заносит значение в пул и возвращает ссылку
на него. В данном случае вывод будет следующим:  
```java 
false // s1 и s2 имеют разные ссылки на объект, т.к. метод intern() не находит в пуле литералов соответсвующего значения.
true // метод equals() сравнил строки по значения (не ссылки на объект) и подтвердил их идентичность
true // после метода intern() строка s2 имеет ссылку на литерал, который был внесен от s1 то есть на "GFG" таким образом 
при инициализации строки s3 (которая инициализируется идентичным литералом) s3 получается на ссылку на тот же что и s2, т.к. такой литерал уже есть в пуле литералов.
```
**Источник:** Разбор на примере - И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 174  

Вопрос 26.
Как преобразовать строку в число?  
**Ответ.**  
Делать это лучше с помощью метода ```parseInt``` класса ```Integer.``` Метод ```parseInt``` должен преобразовать ```String``` в ```int``` и выдает исключение ```NumberFormatException```, если строка не может быть преобразована в тип ```int```.
Пример:  
Основная строка, которая переводит строку в целое число:  
```java
int i = Integer.parseInt (myString);
```  
**Источник.**  https://javarush.ru/groups/posts/244-vopros-otvet-kak-v-java-praviljhno-konvertirovatjh-string-v-int--  

Вопрос 27. 
Какой метод вызывается для преобразования переменной в строку?  
**Ответ.**  
Метод ```toString()``` — используется в Java для получения строкового объекта, представляющего значение числового объекта, другими словами — преобразует число в строку.  
Пример:  
```java
public static String valueOf(Object obj) {
return (obj == null) ? "null" : obj.toString();
}
```
**Источник.**  
https://javastudy.ru/interview/strings/  

Вопрос 28.
Каким методом в классе ```String``` можно проверить строку на соответствие регулярному выражению?  
**Ответ.**  
метод класса ```String - matches()``` принимает регулярное выражение и возвращает ```true```, если строка соответствует этому выражению. Иначе возвращает ```false```.  
Например, проверим, соответствует ли строка номеру телефона:  
```java
String input = "+12343454556";
boolean result = input.matches("(\\+*)\\d{11}");
if(result){
    System.out.println("It is a phone number");
}
else{
    System.out.println("It is not a phone number!");    
}
```
**Источник.**  https://metanit.com/java/tutorial/7.4.php

Вопрос 29.
Создайте класс с полями: ```int, long, float``` и ```double, String```.  
Сделайте для этого класса метод ```toString()```, использующий ```String.format()```, и выведите содержимое полей на экран в произвольном порядке, используя спецификаторы.  
**Ответ:**
```java 
class StringFormatElement {
    private int i = 124127193;
    private long l = 125353191931623723L;
    private float f = 15.7F;
    private double d = 91.37;
    private String st = "my string";
    
    public static void main(String[] args) {
        StringFormatElement s = new StringFormatElement();
        System.out.println(s);
    }
    @Override
    public String toString() {
        return String.format("%d;%d;%f;%f;%s",i,l,f,d,st);
    }
}
```

Вопрос 30.
Опишите:  
назначение класса ```Formatter```,  
методы ```format()```,  
спецификаторы формата.  
**Ответ.**  
Базовой частью поддержки создания форматированного вывода в языке ```Java``` служит класс ```Formatter```, включенный в пакет ```java.util```. Он обеспечивает преобразования формата ```(format conversions)``` позволяющие выводить числа, строки и время и даты практически в любом понравившемся вам формате.
В классе ```Formatter``` объявлен метод ```format()```, который преобразует переданные в него параметры в строку заданного формата и сохраняет в объекте типа ```Formatter```.
Рассмотрим использование класса ```Formatter```:  
```java
import java.util.Formatter;

public class SimpleFormatString {
    public static void main(String[] args) {
        Formatter f = new Formatter();
        f.format("This %s is about %n%S %c", "book", "java", '8');
        System.out.print(f);
    }
}
```
Аналогичный метод ```format()``` объявлен у классов ```PrintStream``` и ```PrintWriter.``` ```System.out``` это статическая переменная типа ```PrintStream```.
В Java 5 для классов ```PrintStream``` и ```PrintWriter``` добавлен метод ```printf()```. Методы ```printf()``` и ```format()``` автоматически используют класс ```Formatter```
С помощью метода ```String.format()``` тоже возможно форматирование.  
Спецификаторы формата:  
%a Шестнадцатеричное значение с плавающей точкой

%b Логическое (булево) значение аргумента  
%c Символьное представление аргумента  
%d Десятичное целое значение аргумента  
%h Хэш-код аргумента  
%e Экспоненциальное представление аргумента  
%f Десятичное значение с плавающей точкой  
%g Выбирает более короткое представление из двух: %е или %f  
%o Восьмеричное целое значение аргумента  
%n Вставка символа новой строки  
%s Строковое представление аргумента  
%t Время и дата  
%x Шестнадцатеричное целое значение аргумента  
%% Вставка знака %  
**Источник.**  https://www.examclouds.com/ru/java/java-core-russian/formatirovanie-strok  

Вопрос 31.
Что представляет собой регулярное выражение?  
На каких классах базируются regex-возможности языка Java?  
В каком пакете эти классы расположены?  
**Ответ.**  
регулярное выражение ```(RegEx)``` – это шаблон для поиска строки в тексте. В ```Java``` исходным представлением этого шаблона всегда является строка, то есть объект класса ```String```. Однако не любая строка может быть скомпилирована в регулярное выражение, а только та, которая соответствует правилам написания регулярного выражения – синтаксису, определенному в спецификации языка.  
Для обработки строк используются классы ```Pattern и Matcher```.
Класс ```Pattern``` используется для простой обработки строк. Для более слож-
ной обработки строк используется класс ```Matcher```.  
Данные классы находятся в пакете ```java.util.regex```.  
**Источник.**  https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java  
И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 177-178

Вопрос 32.
а) Опишите назначение классов ```Pattern``` и ```Matcher```.  
б) Каким образом они связываются?  
в) Предоставить простейший код их взаимодействия.  
**Ответ.**  
а) Класс ```java.util.regex.Pattern``` применяется для определения регулярных
выражений (шаблонов), для которых ищется соответствие в строке, файле
или другом объекте, представляющем последовательность символов.
О каждом соответствии можно получить информацию с помощью класса
```java.util.regex.Matcher```.
С помощью метода ```matches()``` класса ```Pattern``` можно проверять на соответствие шаблону целую строку, но если необходимо найти соответствия внутри
строки, например, определять участки, которые соответствуют шаблону, то
класс ```Pattern``` не может быть использован. Для таких операций необходимо
использовать класс ```Matcher```.  
б) Что бы использовать класс ```Matcher``` вначале надо создать объект ```Pattern```
с помощью статического метода ```compile()```, который позволяет установить шаблон:
```java 
Pattern pattern = Pattern.compile("Hello");
```
В классе ```Pattern``` также определен метод ```matcher(String input)```, который в качестве параметра
принимает строку, где надо проводить поиск, и возвращает объект ```Matcher```   
в) Пример:
```java
String input = "Hello world! Hello Java!";
Pattern pattern = Pattern.compile("Hello");
Matcher matcher = pattern.matcher(input);
```  
**Источник.**  https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java  


Вопрос 33.
При помощи регулярных выражений найти все ссылки внутри веб-страницы, то есть адреса, указанные в атрибуте ```href```.  
**Ответ.**
```java
Pattern p = Pattern.compile("href=\"(.*?)\"");
Matcher m = p.matcher(belGutHtml);
while (m.find()) {
System.out.println(m.group(1));
}
```
**Источник.**  https://seoblog.life/other/regexp-primery.html  

Вопрос 34.
Какой из способов сравнения строк предпочтительнее?  
```str.equals("abc");```
или
```"abc".equals(str);```
Поясните ответ.  
**Ответ.**  
Предпочтительнее второй вариант, т.к. у первого есть недостаток - он может не работать, если ```str == null```  

Вопрос 35.
Как сравнить объекты ```StringBuilder``` и ```StringBuffer```?  
**Ответ.**  
Для классов ```StringBuffer и StringBuilder``` не переопределены методы ```equals()```
и ```hashCode()```, т. е. сравнить содержимое двух объектов невозможно,
следовательно хэш-коды всех объектов этого типа вычисляются так же, как и для
класса ```Object```. При идентичном содержимом у двух экземпляров, размеры буфера
каждого могут отличаться, поэтому сравнение на эквивалентность объектов
представляется неоднозначным.
Сравнить содержимое можно следующим образом:
```java 
StringBuffer sb1 = new StringBuffer(48);
StringBuilder sb2 = new StringBuilder(48);
sb2.toString().contentEquals(sb1);
```
Метод  ```contentEquals()```  проводит сравнение строки и содержимого объекта типа ```StringBuffer```;  
**Источник.**  И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 171


Вопрос 36.
Что появится в консоли в результате работы фрагмента программы?
```java
System.out.printf(
"%d студентов пришли сдавать зачет по %8.10s, \n"
+ "из них не сдали %d, %s",
10, "J2SE", 5, "а остальные сдали на отлично"
);
```
Поясните ответ.  
**Ответ.**  
```
// System.out.printf выводит в консоль данные форматируя строку как и String.format() 
10 студентов пришли сдавать зачет по     J2SE, // вместо %d в начале строки будет вставлено целочисленная переменная идущая первая по порядку, т.е. 10
%8.10s указывает растояние до следущей строки  s = "J2SE" в пробелах. То есть 8.10 длина пробельного расстояния. 
из них не сдали 5, а остальные сдали на отлично // %d и %s будут заменены на следующие по порядку числовую переменную и строковое значение соотвественно
т.е. на 5 и строку = "а остальные сдали на отлично"
```  

Вопрос 37.
Сформировать регулярное выражение, при помощи которого можно выбрать все страницы, начинающиеся с ```http``` или ```https``` и заканчивающиеся на ```by```.  
**Ответ.**  
```java
String regForSearch = "(https|http)://www.(.+)(by/)"
```

Вопрос 38.
Сформировать регулярное выражение, при помощи которого можно выбрать все значения ```URL```-запроса с ресурса https://bsut.by.
Например, запрос https://bsut.by?value1=5&value2=10&iscan=true.
Вывод
```java
value1=5
value2=10
iscan=true
```
**Ответ.**  
```java
String regString = "[?&]";
``` 

Вопрос 39.
Базовые конструкции регулярных выражений, синтаксис (очень коротко, суть). Специальные символы, основные логические конструкции, предопределенные классы символов, логические операции, квантификаторы, группы.  
Синтаксис регулярных выражений основан на использовании символов <([{\^-=$!|]})?*+.>, которые можно комбинировать с буквенными символами.  
конструкции:\
`[abc]` - a или b или c.\
`[^abc]` - символ, исключая a, b и c.\
`[a-z]` - символ между a и z.\
спец символы:\
`.` - любой символ\
`\d` или `\p{Digit}` - [0-9]\
`\D` - [^0-9]\
`\s` или \p{Space} -[ \t\n\x0B\f\r]\
`\S` - [^\s]\
`\w` - [0-9_A-Za-z]\
`\W` - [^\w]\
`^` или `\A` - начало строки\
`$` или `\Z` - конец строки\
логические конструкции:\
`ab` - после а следует b\
`a|b` - a или b\
квантификаторы:\
`a?` - a один раз или ни разу\
`a*` - a ноль или более раз\
`a+` - a один или более раз\
`a{n}` - a n раз\
`a{n,}`  - a n или более раз\
`a{n,m}` - a от n до m\
Группы — способ обработки набора символов как одного.\
Каждая открывающая скобка слева направо нумерует группу. Выражение `((A)(B(C)))` определяет четыре группы:\
• ((A)(B(C)))\
• (A)\
• (B(C))\
• (C)\
**Источник.**  https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java
И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 234

Вопрос 40.
Назовите основные, на ваш взгляд, методы класса ```Pattern```.  
**Ответ.**  
Для простого поиска соответствий в классе ```Pattern``` определен статический метод ```boolean matches(String pattern, CharSequence input)```. Данный метод возвращает ```true```, если последовательность символов ```input``` полностью соответствует шаблону строки ```pattern```  
```Pattern compile(String regex)``` — возвращает ```Pattern```, который соответствует ```regex```  
```Matcher matcher(CharSequence input)``` — возвращает ```Matcher```, с помощью которого можно находить соответствия в строке ```input```.  
```String[] split(CharSequence input)``` — разбивает строку ```input```, учитывая, что
разделителем является шаблон  
**Источник.**  https://metanit.com/java/tutorial/7.4.php  
И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 171  

Вопрос 41.
Назовите основные, на ваш взгляд, методы класса ```Matcher```.  
**Ответ.**  
а) ```boolean matches()```: возвращает ```true```, если вся строка совпадает с шаблоном  
б) ```boolean find()```: возвращает ```true```, если в строке есть подстрока, которая совпадает с шаблоном, и переходит к этой подстроке  
в) ```String group()```: возвращает подстроку, которая совпала с шаблоном в результате вызова метода ```find```. Если совпадение отсутствует, то метод генерирует исключение ```IllegalStateException```.  
г) ```int start()```: возвращает индекс текущего совпадения  
д) ```int end()```: возвращает индекс следующего совпадения после текущего  
е) ```String replaceAll(String str)```: заменяет все найденные совпадения подстрокой ```str``` и возвращает измененную строку с учетом замен  
**Источник.** https://metanit.com/java/tutorial/7.4.php  

Вопрос 42.
Что появится в консоли в результате работы фрагмента программы?
```java
System.out.println{"-1234".matches("-?\\d+"));
System. out. println ("5678". matches (" - ? \ \d+"));
System.out.println("+9ll".matches("-?\\d+"));
System.out.println("+911".matches("(-|\\+)?\\d+"));
```
Поясните ответ.  
**Ответ.**  
``` 
true /* регулярное выражение соотвествует заданной строке. -? подразумевает что - необязателен
      \\d+ - один или несколько элементов числового символа
      */
Error : illegal escape character т.к. в регулярном выражении попадают на сопоставление символы \ разделенные пробелами.
Если рассматривать выражение без пробелов т.е. System. out. println ("5678". matches ("-?\\d+")); Тогда результатом будет true;
1
false /* регулярное выражение не соответсвует заданной строке. -? проверку проходит (см. первую строку ответа)
однако \\d+ не проходит проверку на соотвествие т.к. после числового символа 9 стоят 2 буквенных символа l, 
регулярное выражение не указывает что после \\d могут стоят буквенные символы либо любые другие. 
*/
true /* регулярное выражение соотвествует заданной строке. | - знак "или", в данном случае предполагает
что в начале строки будет стоять либо '-' либо '+' далее уже разобранное выше регулярное выраженеи с числовыми символами.
*/
```  


Вопрос 43.
Что появится в консоли в результате работы фрагмента программы?  
```java
System.out.println(
Arrays
.toString("Then, when you have found the gold."
.split("n\\W+")
)
);
```
Поясните ответ.  
**Ответ.**  
```[The, whe, you have found the gold.]```
В данном случае ```split("n\\W+")``` разделяет строку на подстроки, и вносит их в массив, который после выводится в консоль.
Регулярное выражение для разделение подразумевает некую подстроку начинающуюся на "n" имеющее хотя бы 1 символ кроме буквенного, числового или нижнего подчеркивания.  

Вопрос 44.
Сформируйте и протестируйте регулярное выражение, которое проверяет, что предложение начинается с прописной буквы и завершается точкой.  
**Ответ.**  
```java 
System.out.println("Hey! It's some string --> 23.".matches("(\\p{Upper})(.+)(\\.)");
```

Вопрос 45.
Сформируйте и протестируйте регулярное выражение, которое заменяет все гласные подчеркиваниями в предложении
"Then, when you have found the gold".  
**Ответ.**
```java 
System.out.println("Then, when You have found the gold".
                replaceAll("(?i)[aouyie]","_"));
```

Вопрос 46.
Определите, будет ли найдено в строке
"Java now has regular expressions"
совпадение для следующих выражений:
```
^Java
\Breg.*
n.w\s+h(a|i)s
s?
s*
s+
S{4}
S{1}
S{0,3}
```
Поясните ответ.  
```java 
^Java\\Breg.*n.w\\s+h(a|i)ss?\\s*\\s+\\S{4}\\S{1}\\S{0,3}
```
В таком случае выводом будет false;
```java 
^Java // Начало строки - Java = true
\Breg.* // \B - не граница слова = ??
n.w\s+h(a|i)s // n + любой символ + w + \\s = пробел + h + a или i + s === true
s? s - либо один раз встречается либо отсутсвует == true 
\\s* s - встречается 0 или более раз = true
\\s+ s - встречается 1 или более раз = true 
\\S{4} - 4 повтора символа "S" = true
\\S{1} - 1 непробельный символ = true
\\S{0,3} - 0-3 непробельных символа = true
```
Корректная проверка:
```java 
System.out.println("Java now has regular expressions".
                matches("^Java.*n.w\\s+h(a|i)ss?\\s+\\S{4}\\S{1}\\S{0,3}.*"));
```

Вопрос 47.
Примените регулярное выражение
```java
(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b
```
к строке
"Arline ate eight apples and one orange while Anita hadn't any"
Поясните ответ.  
**Ответ.**  
```java 
(?i) // допускает любой регистр для следующих символов = true
((^[aeiou])|(\s+[aeiou])) // либо начало строки начинается с гласной либо с пробела или нескольких, а затем гласной = true
\w+?[aeiou]\b после идет // после идет один или более символ равный буквенному, числовому или знаку подчеркивания = true
после гласная и граница слова = true
```

Вопрос 48.
Какие подстроки извлекают следующие регулярные выражения?  
```java
[0-6]
[^n-p]
[A-Za-z0-9_]
\w
[A-C][n-p][a-c]
waz{3,5}up
[abc]+
.*
```
**Ответ.**  
```java 
[0-6] - числовые символы от 0 до 6
[^n-p] - начало строки - символ от n до p (в нижнем регистре)
[A-Za-z0-9_] - все буквенные символы, числовые от 0 до 9 и нижнее подчеркивание
\w - все буквенные символы, числовые от 0 до 9 и нижнее подчеркивание
[A-C][n-p][a-c] - буквенные символы от a до c вне зависимости от регистра, от n до p в нижнем регистре
waz{3,5}up - wa + символ z повторяющийся от 3 до 5 раз + up
[abc]+ - символы a,b или c повторяющиеся один или более раз.
.* - любой символ повторяющийся 0 или более раз
```

Вопрос 49.
Сформируйте регулярное выражение, которое находит предложения, начинающиеся с "Input:" и заканчивающиеся на "successful".  
**Ответ.**  
```java 
System.out.println("Input sta b 22 successful".
                matches("^(Input).*(successful)$")); 
                // ^ - начало строки соответсвует тому что в скобках
                // .* - любой символ повторяющийся 0 или более раз
                // $ - конец строки соотвествует тому что было заданно в скобках до знака
```  

Вопрос 50
Сформируйте регулярное выражение, которое выделяет в обрабатываемом тексте названия файлов (имя + расширение) графических форматов ```gif```, ```png```, ```jpg```.  
```java 
System.out.println("in.png".
                matches(".*\\.((gif)|(png)|(jpg))$"));
```
